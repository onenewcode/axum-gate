---
description: Combined AI ruleset (model-agnostic) for Zed; aggregated from ai-ruleset/src categories: rust global. Generated by build.sh.
globs: "**/*"
---

# AI Ruleset (Combined)

_This file is generated. Do not edit manually. Sources: ai-ruleset/src/{rust,global}/_


## Source: rust/rust.md

# Rust Best Practices for AI-Assisted Development

## Rust API Guidelines Alignment

The following rules complement this guide with the Rust API Guidelines. Apply them when designing public APIs:

- Naming and casing
  - Follow RFC 430: modules `snake_case`; types and traits `UpperCamelCase`; functions and methods `snake_case`; constants and statics `SCREAMING_SNAKE_CASE`.
  - Getter methods generally omit the `get_` prefix; prefer `foo()` and `foo_mut()` except for types like `Cell` that conventionally use `get`.
  - Use consistent word order for error and helper types (e.g., `ParseIntError`).
  - Feature names are meaningful and additive: avoid placeholder prefixes like `use-`/`with-` and negative names like `no-*`; prefer canonical names such as `std` and `serde` that compose additively.

- Conversions
  - Use ad‑hoc conversion naming conventions: `as_` for free, `to_` for potentially expensive, `into_` for ownership‑consuming conversions.
  - Implement conversion traits where applicable: `From`/`TryFrom`, `AsRef`/`AsMut`. Do not implement `Into`/`TryInto` directly; they derive from `From`/`TryFrom`.
  - Provide `into_inner()` to expose wrapped inner values when appropriate.
  - Place ad‑hoc conversions and constructors on the most specific type involved to keep call sites predictable.

- Iterators
  - Collection iterator methods should be named `iter`/`iter_mut`/`into_iter`; iterator types should match (`Iter`, `IterMut`, `IntoIter`).
  - Prefer iterator adapters; collections implement `FromIterator` and `Extend` to integrate with `collect`, `partition`, and `unzip`.

- Serde integration
  - Data‑structure types should implement `Serialize` and `Deserialize`.
  - Gate Serde implementations behind a `serde` Cargo feature for opt‑in usage: `serde = { version = "1", features = ["derive"], optional = true }`.

- Send/Sync and thread‑safety
  - Ensure public types are `Send`/`Sync` when semantically correct; add tests to assert these auto‑traits to prevent regressions.

- Error types
  - Public error types implement `std::error::Error` and `Display`, and should be `Send + Sync + 'static` when possible.
  - Use clear, concise, lowercase `Display` messages without trailing punctuation. Never use `()` as an error type.

- Numeric formatting
  - Numeric types that conceptually support bitwise operations should implement `UpperHex`, `LowerHex`, `Octal`, and `Binary` formatting traits for use with `{:X}`, `{:x}`, `{:o}`, and `{:b}`.

- Reader/writer APIs
  - Generic I/O functions take `R: Read` and `W: Write` by value; callers can pass `&mut R`/`&mut W` due to blanket impls. Document this in API docs.

- Macros
  - Prefer evocative input syntax; item macros should work where items are allowed, compose with attributes, and support visibility specifiers; use flexible type fragments; maintain macro hygiene.

- Predictability and methods
  - Functions with a clear receiver are inherent methods; avoid out‑parameters; operator overloads should be unsurprising.
  - Only smart pointers implement `Deref`/`DerefMut`. Constructors are inherent `new` or `with_*` methods.
  - Smart pointers should avoid adding unrelated inherent methods; prefer putting behavior on the inner type or via traits to keep APIs unsurprising.

- Flexibility
  - Expose intermediate results to avoid duplicate work; minimize assumptions via generics; ensure traits intended for dynamic dispatch are object‑safe.

- Type safety
  - Use newtypes to create static distinctions and hide implementation details; prefer `bitflags` for sets of flags; use builders for complex construction.
  - Avoid `bool`/`Option` parameters in public APIs when they obscure intent; prefer dedicated enums or newtypes that convey meaning explicitly.
  - Do not duplicate derived trait bounds on generic data structures; prefer deriving common traits on the type itself.

- Dependability and debuggability
  - Validate inputs at public boundaries; destructors never fail; provide alternatives for potentially blocking destructors.
  - All public types implement `Debug`, and `Debug` output is non‑empty and useful.

- Future‑proofing
  - Seal traits that should not be implemented downstream; document in rustdoc that they are sealed and not intended for external implementation; keep struct fields private; use `#[non_exhaustive]` on public enums/structs where appropriate to allow adding variants/fields later.

- Necessities
  - Public dependencies of a stable (>= 1.0) crate must themselves be stable.
  - Use permissive licensing compatible with the Rust ecosystem (MIT OR Apache‑2.0) and include license files.

- Documentation and examples
  - Crate‑level docs are thorough and include examples; all public items have rustdoc examples when reasonable.
  - Examples use the `?` operator instead of `unwrap` or `try!` and compile as doctests in CI.
  - Function docs include `# Errors`, `# Panics`, and `# Safety` sections when applicable; add links to related items; hide unhelpful implementation details with `#[doc(hidden)]` and `pub(crate)`.

> 2024 edition idioms quick reference
- Immutability first: prefer `let` without `mut`; use `mut` only when necessary; prefer shadowing for transformations when it improves clarity.
- Closures and iterators: favor iterator adapters and combinators over indexing and manual loops; understand capture traits `Fn`, `FnMut`, and `FnOnce`; avoid boxing closures unless needed for type erasure or dynamic dispatch; iterators are zero-cost and often faster than manual loops.
- Generics vs trait objects: default to generics for static dispatch and monomorphization; use `dyn Trait` when you need heterogeneity, plugin-like behavior, or to reduce code size; ensure the trait is object safe when using `dyn Trait`.
- Interior mutability: prefer external mutability first; use `Cell<T>`/`RefCell<T>` in single-threaded code and `Mutex<T>`/`RwLock<T>` under `Arc<T>` for multi-threaded code; document borrowing and locking invariants clearly.
- Deriving common traits: derive `Debug`, `Clone`/`Copy` (when trivially copyable), `Eq`/`PartialEq`, `Ord`/`PartialOrd`, `Hash`, and `Default` where appropriate; implement manually only to preserve invariants; consider `#[non_exhaustive]` on public enums/structs to allow future expansion.
- Main returns Result: prefer `fn main() -> Result<(), Box<dyn std::error::Error>> { ... }` and use `?` at the top level; for async binaries use `#[tokio::main]` and return `Result<(), anyhow::Error>` or similar to enable `?` in `main`.
- Testing attributes: use `#[test]`, `#[tokio::test]`, `#[should_panic(expected = "...")]`, and `#[ignore]` as needed; tests can return `Result<(), E>` to use `?`; organize unit tests in modules and integration tests under `tests/`.
- Use-path idioms: bring the parent module for functions (`use crate::module; module::func()`), import types with full paths (`use std::collections::HashMap`), use nested paths and `as` aliases to reduce noise; avoid glob imports except in tests or prelude patterns; re-export with `pub use` to curate a clean public API.

Expert-level Rust programming guidance optimized for AI-assisted development workflows.

## AI-Optimized Development Principles

### Context-Aware Code Generation
- Always provide complete module context including all necessary imports (`use` statements)
- Include relevant configuration files (Cargo.toml, .cargo/config.toml) when generating projects
- Generate complete function signatures with proper parameters, return types, lifetimes, and bounds
- Include comprehensive documentation comments (`///`) explaining purpose, parameters, examples, and safety considerations
- Provide context about the module's role in the larger system architecture
- Follow proper module organization and crate structure with clear dependency graphs
- Include error handling context and propagation patterns
- Specify trait bounds and generic constraints explicitly
- For any non-trivial change, generate or update tests alongside code (unit and/or integration), covering both success and error paths
- If the complete answer may exceed tool or model limits, propose a plan and split the work into steps
- When requirements are ambiguous, ask one clarifying question, then proceed with a conservative, safe default

### IDE Integration
- Structure code for optimal Go-to-Definition and Find References functionality
- Use consistent naming conventions that support fuzzy finding and navigation
- Organize imports in standard order: std, external crates, local crates, modules
- Implement proper rust-analyzer integration with meaningful symbols
- Use explicit type annotations for complex expressions to improve IDE experience
- Structure projects with clear module hierarchies for better code navigation
- Configure workspace settings for optimal Rust development experience

## Modern Rust Patterns and Idioms

### Ownership, Borrowing, and Lifetimes
- Prefer borrowing (`&T`, `&mut T`) in function parameters; take ownership when the function must consume or store the value.
- Avoid unnecessary clones; clone explicitly at API boundaries when needed.
- Prefer `&str` and `&[T]` in APIs over `String` and `Vec<T>` when ownership is not required. Return owned types when constructing new data.
- Use slices, iterators, and pattern matching over indexing to avoid panics; use `get`/`get_mut` for checked access.
- Rely on lifetime elision rules for simple cases; otherwise, name lifetimes to express relationships between borrows. Avoid `'static` unless required.

### Collections
- Choose the simplest collection that fits: `Vec<T>` for ordered lists, `String` for text, `HashMap<K, V>` for key/value. Reserve capacity when size is known.
- Use `Option` and `Result` in APIs rather than sentinel values.
- Use iterators and adapter methods; prefer `collect` and `FromIterator` to manual loops when it improves clarity
- Strings: prefer `String::from` and `.to_string()` for construction; use `push_str`/`push` for appending, `format!` for interpolation; avoid indexing into `String` (use slicing on valid UTF-8 boundaries or iterate via `.chars()`/`.bytes()` when appropriate)
- Pattern matching: prefer `match` for exhaustive handling; use `if let`/`while let` for single-branch convenience; use `matches!` for boolean conditions; include a `_` catch-all only when you intentionally want to ignore remaining cases

### Modules and Paths
- Use `mod` to declare modules and keep files organized; place submodules in directories that mirror the module tree.
- Use `pub` to control visibility; re-export with `pub use` to create a clean public API.
- Group `use` statements logically (std, external crates, local); avoid glob imports in libraries.
- Remember `mod` is not a textual include; define items where the module is declared.
- Prefer the newer file layout for modules: `src/module.rs` and `src/module/submodule.rs` rather than legacy `mod.rs` files, for clearer editor navigation

### Documentation Standards
- Document public items with rustdoc and runnable examples; keep examples minimal and focused.
- Include `# Panics`, `# Errors`, and `# Safety` sections as appropriate to document contracts and invariants.
- Ensure doctests compile and run via `cargo test` in CI.

### Concurrency (std)
- For simple parallelism, use `std::thread::spawn` and `JoinHandle::join`.
- Share immutable data with `Arc<T>`; protect shared mutable state with `Arc<Mutex<T>>` or `Arc<RwLock<T>>`.
- Use `std::sync::mpsc` channels for message passing in synchronous code.
- In async contexts, avoid blocking the runtime; offload blocking work appropriately.

### Type System Excellence
- Leverage the type system to encode invariants and prevent runtime errors
- Use newtype patterns to create domain-specific types with clear semantics
- Implement proper trait design with associated types and generic parameters
- Use const generics for compile-time parameterization where appropriate
- Implement proper error types with thiserror or custom error enums
- Use phantom types and zero-sized types for compile-time guarantees
- Leverage type-level programming with const assertions where beneficial

### Memory Management and Performance
- Follow ownership patterns: prefer owned types, borrow when necessary
- Use `Cow<'_, T>` for flexible ownership in APIs that might clone
- Implement proper lifetime management with explicit annotations when needed
- Use `Rc<T>` for single-threaded shared ownership; use `Arc<T>` for multi-threaded or async tasks that may hop threads
- Do not use `Rc` in multi-threaded contexts; it is neither `Send` nor `Sync`
- Prefer `Arc::clone(&value)` and `Rc::clone(&value)` over calling `clone()` on the smart pointer value directly for explicit semantic clarity
- Prefer stack allocation; use heap allocation (`Box`, `Vec`) when size is dynamic
- Use `Pin` and `Unpin` correctly for self-referential structures
- Implement zero-cost abstractions with proper inlining and generic specialization
- Profile and optimize hot paths with appropriate benchmarking

### Error Handling Patterns
- Prefer returning `Result<T, E>` as the default for operations that can fail.
- Panicking is appropriate when an invariant/contract is violated and continuing would be unsafe or incorrect; document such cases in API docs.
- In examples, prototypes, and tests, it is acceptable to use `unwrap`/`expect`.
- It is acceptable to call `expect` with a clear explanation when failure is logically impossible but not provable to the compiler (e.g., parsing a hardcoded constant).
- Create comprehensive custom error types using `thiserror` or manual implementations
- Use `Result<T, E>` consistently. Avoid `unwrap()`/`expect()` in libraries and applications; use them freely in examples, prototypes, and tests. In production, only call `expect` when failure is logically impossible and document why; otherwise propagate errors with `?`. Prefer returning typed errors over panicking, except to signal violated invariants.
- Implement proper error propagation with `?` operator and custom `From` implementations
- Use `anyhow` for application-level error handling with context
- Implement graceful degradation patterns for non-critical failures
- Create error hierarchies that provide useful debugging information
- Use `tracing` for structured error logging with proper context

## Code Organization and Architecture

### Project Structure
```
src/
├── verification_result.rs
├── comma_separated_value.rs
├── groups.rs
├── roles.rs
├── lib.rs
├── cookie_template.rs
├── route_handlers.rs
├── credentials
│   ├── credentials_verifier.rs
│   └── mod.rs
├── secrets
│   ├── secret_repository.rs
│   └── mod.rs
├── audit.rs
├── hashing
│   ├── hashing_service.rs
│   ├── mod.rs
│   └── argon2.rs
├── jwt
│   ├── mod.rs
│   ├── validation_result.rs
│   └── validation_service.rs
├── codecs
│   ├── logout.rs
│   ├── mod.rs
│   └── login.rs
├── authn
│   ├── mod.rs
│   ├── access_scope.rs
│   ├── access_hierarchy.rs
│   ├── authorization_service.rs
│   └── access_policy.rs
├── authz
│   ├── account_delete.rs
│   ├── account_repository.rs
│   ├── account_insert.rs
│   └── mod.rs
├── accounts
│   ├── mod.rs
│   ├── bearer
│   │   ├── static_token_authorized.rs
│   │   └── mod.rs
│   └── cookie
│       ├── cookie_service.rs
│       └── mod.rs
├── gate
│   ├── mod.rs
│   ├── models
│   │   ├── credentials.rs
│   │   ├── account.rs
│   │   └── permission_mapping.rs
│   ├── sea_orm
│   ├── memory.rs
│   ├── sea_orm.rs
│   └── surrealdb.rs
├── repositories
│   ├── validate_permissions.rs
│   ├── permission_collision.rs
│   ├── as_permission_name.rs
│   ├── permission_id.rs
│   ├── application_validator.rs
│   ├── validation_report.rs
│   ├── collision_checker.rs
│   └── mod.rs
├── mapping
│   ├── mapping_repository.rs
│   └── mod.rs
├── permissions
│   ├── domain.rs
│   ├── mod.rs
│   ├── application.rs
│   ├── infrastructure.rs
│   └── ports.rs
├── errors
```

### Module Design Principles
- Design modules with clear, single responsibilities
- Establish a single canonical way to achieve a given goal; avoid multiple equivalent APIs or constructors. For example, provide exactly one clear constructor path for a struct (exceptions: trait-based constructors like `Default`, `From`/`TryFrom`, or `serde::Deserialize`)
- Create stable public APIs with semantic versioning considerations
- Use `pub(crate)` for internal APIs that shouldn't be exposed
- Implement proper module documentation with usage examples
- Design for testability with dependency injection patterns
- Enforce category-domain boundaries: categories are top-level business groupings; domains are submodules within a category
- Dependencies flow inward: delivery-facing modules (e.g., `route_handlers.rs`) depend on category/domain modules; category/domain modules depend only on shared technical modules within the crate (e.g., `hashing`, `jwt`, `repositories`) and Rust std/libs; never on delivery modules or unrelated categories directly
- Cross-category interactions occur via explicit interfaces (traits) and dedicated integration modules; avoid direct imports between categories and avoid cyclic dependencies
- Surface public API via `mod.rs` per domain; keep internal modules `pub(crate)` unless deliberately shared

### Dependency Management
```toml
# Cargo.toml - Use Rust 2024 edition; specify only major versions unless specific fixes needed
[package]
edition = "2024"

[dependencies]
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
tracing = "0.1"
anyhow = "1"
thiserror = "1"

[dev-dependencies]
tokio-test = "0.4"
criterion = "0.5"
proptest = "1"
```

## Async Programming Excellence

### Modern Async Patterns
- Use `async`/`await` consistently; avoid blocking operations in async contexts; prefer end-to-end async instead of running async code from sync functions via executors (no `block_on`, no ad-hoc runtimes). Use `tokio::task::spawn_blocking` only when truly necessary to isolate unavoidable blocking work.
- Implement proper async trait patterns with `async-trait` when needed
- Use `tokio::task::spawn_blocking` for CPU-intensive or blocking operations
- Implement proper stream processing with `futures::Stream` and async iterators
- Use `tokio::select!` for concurrent operations with cancellation
- Implement proper async error handling with context preservation
- Use async-friendly data structures and synchronization primitives

### Concurrency and Parallelism
- Choose appropriate synchronization primitives (Mutex, RwLock, Semaphore)
- Use message passing with channels (`mpsc`, `broadcast`, `watch`) when appropriate
- Implement proper backpressure handling in streaming scenarios
- Use `Arc` for shared state in multi-threaded contexts
- Implement graceful shutdown patterns for long-running services
- Use work-stealing executors appropriately for different workloads

## Testing and Quality Assurance

### Comprehensive Testing Strategy
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tokio_test;
    use proptest::prelude::*;

    #[tokio::test]
    async fn test_async_operation() {
        // Test async operations with proper setup/teardown
    }

    proptest! {
        #[test]
        fn test_property_based(input: Vec<u32>) {
            // Property-based testing for edge cases
        }
    }

    #[test]
    fn test_unit_functionality() {
        // Unit tests with clear arrange/act/assert structure
    }
}
```

### Test Organization
- Write unit tests for individual functions and methods
- Create integration tests in the `tests/` directory
- Use property-based testing with `proptest` for comprehensive coverage
- Implement benchmark tests with `criterion` for performance validation
- Create test utilities and fixtures for common test scenarios
- Mock external dependencies with appropriate test doubles
- Test error conditions and edge cases thoroughly
- Use `assert!`, `assert_eq!`, `assert_ne!`, and `matches!` macros; prefer approximate comparisons for floats (e.g., via `approx` crate) when needed
- Consider writing tests that return `Result<(), E>` and use `?` for fallible setup/teardown to keep test code clear

## Security and Safety

### Memory Safety
- Leverage Rust's ownership system to prevent memory safety issues
- Use `unsafe` code sparingly and document safety invariants clearly
- Implement proper bounds checking and validation for all inputs
- Use safe abstractions over unsafe operations when possible
- Audit unsafe code blocks with clear safety documentation

### Input Validation and Sanitization
```rust
use serde::{Deserialize, Serialize};
use validator::{Validate, ValidationError};

#[derive(Debug, Deserialize, Validate)]
pub struct UserInput {
    #[validate(length(min = 1, max = 100))]
    pub name: String,
    
    #[validate(email)]
    pub email: String,
    
    #[validate(range(min = 18, max = 120))]
    pub age: u8,
}

impl UserInput {
    pub fn validate_and_sanitize(self) -> Result<ValidatedUserInput, ValidationError> {
        self.validate()?;
        Ok(ValidatedUserInput {
            name: self.name.trim().to_string(),
            email: self.email.to_lowercase(),
            age: self.age,
        })
    }
}
```

### Security Best Practices
- Validate all external input at system boundaries
- Use secure random number generation with `rand::thread_rng()`
- Implement proper authentication and authorization patterns
- Use secure serialization formats and validate deserialized data
- Handle secrets securely without logging sensitive information
- Implement rate limiting and request throttling mechanisms

## Performance Optimization

### Profiling and Benchmarking
```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn benchmark_function(c: &mut Criterion) {
    c.bench_function("operation", |b| {
        b.iter(|| {
            black_box(expensive_operation(black_box(input_data())))
        })
    });
}

criterion_group!(benches, benchmark_function);
criterion_main!(benches);
```

### Optimization Strategies
- Profile before optimizing using `cargo flamegraph` or `perf`
- Use appropriate data structures for the access patterns
- Implement lazy evaluation patterns where beneficial
- Use `const` functions and const evaluation for compile-time computation
- Optimize allocations by reusing buffers and using object pools
- Use SIMD operations through portable abstractions when appropriate

## Documentation and Maintenance

### Comprehensive Documentation
```rust
/// Processes user data with validation and transformation.
///
/// # Arguments
///
/// * `input` - Raw user input requiring validation
/// * `config` - Processing configuration options
///
/// # Returns
///
/// Returns a `Result` containing processed data or validation errors.
///
/// # Examples
///
/// ```rust
/// use myapp::{UserInput, Config, process_user_data};
///
/// let input = UserInput::new("John", "john@example.com");
/// let config = Config::default();
/// let result = process_user_data(input, &config)?;
/// ```
///
/// # Errors
///
/// This function returns an error if:
/// - Input validation fails
/// - External service is unavailable
/// - Processing constraints are violated
pub async fn process_user_data(
    input: UserInput,
    config: &Config,
) -> Result<ProcessedData, ProcessingError> {
    // Implementation
}
```

### Maintenance Patterns
- Place attributes directly above the item they modify. The canonical order is: Documentation (`///`), Attributes (`#[...]`), then the Definition. Apply consistently for structs, enums, traits, functions, and methods.
- Do not mix outer doc comments (`///`) and inner doc comments (`//!`) within the same module or item. Use outer doc comments (`///`) for documenting individual items (functions, structs, enums, etc.) and inner doc comments (`//!`) only for module-level or crate-level documentation. Mixing these styles creates inconsistent documentation patterns and should be avoided.
- Do not change crate-level attributes (e.g., `#![deny(missing_docs)]`, `clippy::all`, or other `warn`/`allow`/`deny` settings) without explicit confirmation. By default, changes are prohibited. If a change is explicitly approved, use the narrowest possible `#[allow(...)]` with a clear justification, and prefer scoping to test-only code via `#[cfg(test)]`.
- Use `#[deprecated]` attributes with migration guidance for API changes
- Implement feature flags with `cfg` attributes for experimental features
- Create changelog entries following semantic versioning principles
- Use cargo workspaces for multi-crate projects with shared dependencies
- Implement proper CI/CD pipelines with comprehensive checks
- Edition migration: when upgrading editions, run `cargo fix --edition` and consult the Edition Guide; commit changes and ensure `edition = "2024"` in `Cargo.toml`

## AI-Friendly Code Patterns

### Explicit Context Provision
- Include all necessary imports and module declarations
- Provide complete function signatures with explicit types
- Include comprehensive error types and handling patterns
- Document all public APIs with examples and constraints
- Structure code with clear separation of concerns

### Maintainable Abstractions
```rust
// Good: Clear trait with documented behavior
pub trait UserRepository {
    type Error: std::error::Error + Send + Sync + 'static;
    
    /// Finds a user by their unique identifier.
    /// Returns None if no user exists with the given ID.
    async fn find_by_id(&self, id: UserId) -> Result<Option<User>, Self::Error>;
    
    /// Saves a user, creating or updating as needed.
    /// Returns the saved user with any generated fields populated.
    async fn save(&self, user: User) -> Result<User, Self::Error>;
}

// Implementation with proper error handling
#[derive(Debug, thiserror::Error)]
pub enum DatabaseError {
    #[error("Connection failed: {0}")]
    Connection(#[from] sqlx::Error),
    
    #[error("Validation failed: {message}")]
    Validation { message: String },
    
    #[error("Resource not found: {resource_type} with id {id}")]
    NotFound { resource_type: String, id: String },
}
```

## Advanced Patterns and Techniques

### Macro Design
- Create declarative macros that generate boilerplate code
- Use procedural macros for compile-time code generation
- Follow macro hygiene principles to avoid name collisions
- Provide clear error messages for macro usage errors
- Document macro usage with comprehensive examples

### Generic Programming
- Design generic APIs that work with multiple types
- Use associated types appropriately for cleaner APIs
- Implement proper trait bounds with where clauses
- Use higher-ranked trait bounds (HRTB) when needed for lifetime polymorphism
- Create type-level computations with const generics

### Foreign Function Interface (FFI)
- Design safe Rust wrappers around unsafe FFI functions
- Use proper memory management across language boundaries
- Implement proper error handling for FFI operations
- Document safety requirements and invariants clearly
- Use `bindgen` for automatic binding generation when appropriate

## Design Patterns and Rust Idioms

Rust favors composition, traits, and enums over inheritance. Many classic GoF patterns map to simpler, more idiomatic Rust solutions:

- Strategy
  - Prefer passing behavior as closures or types implementing `Fn`/`FnMut`/`FnOnce`. Use trait objects (`dyn Trait`) when you need heterogeneity at runtime; prefer generics for static dispatch.
  - Keep strategy selection close to use-sites. For libraries, expose a trait with small, object-safe methods, and provide convenient constructor helpers for common strategies.
  - For simple pipelines, favor iterator adapters and higher-order functions over explicit strategy objects.

- State
  - If states are known and closed, prefer a single `enum` with methods and exhaustive `match` for transitions (simple, efficient, compile-time checked).
  - If states need open extension or dynamic selection, use a state trait with `self: Box<Self>` methods that consume and return `Box<dyn State>` (as in the Book). Keep transitions explicit and document invariants.

- Adapter
  - Prefer standard conversions and newtypes: implement `From`/`TryFrom`/`AsRef` instead of bespoke adapters when converting data.
  - For behavior adaptation, create thin wrapper types that implement the required trait and delegate to the adaptee. Re-export with `pub use` for ergonomic discovery.

- Decorator
  - Compose behavior with wrapper types around a trait (e.g., `Read`/`Write`), forwarding calls to the inner object and adding functionality (cf. `BufReader`).
  - Avoid adding unrelated inherent methods to smart pointers. Keep decorators small, orthogonal, and stackable.

- Mediator
  - Prefer explicit coordination with a top-level owner that holds participants and orchestrates calls, enforcing borrow rules at compile time.
  - If shared mutable graph-like coordination is required, use `Rc<RefCell<T>>` in single-threaded code or `Arc<Mutex<T>>` in multi-threaded contexts. Document borrowing/locking invariants, and minimize interior mutability.

- Singleton
  - Avoid global mutable state. Prefer passing dependencies through constructors (dependency injection).
  - If a global is required, use `OnceCell`/`Lazy` or a `static Mutex` (const-initialized) to provide safe, one-time initialization and synchronized access. Hide any `unsafe` behind a safe API.

- Command
  - Represent commands as:
    - An `enum` with an `execute(&mut self, ctx)` method (exhaustive match, simple undo via Memento-like snapshots), or
    - Trait objects/closures when heterogeneity is needed and the set is open.
  - Prefer data-oriented commands with explicit inputs/outputs; keep side effects scoped and testable.

- Visitor
  - Prefer `enum` plus exhaustive pattern matching when you control the visited types.
  - If the set of visited types is open and you need external extensibility, consider a sealed visitor trait with default no-op methods; document object safety and versioning constraints.

- Bridge
  - Separate abstraction from implementation with traits. Use generics for static dispatch and `dyn Trait` for pluggable backends.
  - Keep the abstraction small and stable; hide implementation details behind modules and re-exports.

- Abstract Factory / Factory Method
  - Prefer `From`/`TryFrom`/builders for constructing complex types. For runtime selection, use an `enum` to choose variants or a trait-based factory with object safety.
  - Avoid global registries; wire factories at the composition root.

- Observer
  - Favor message passing over callbacks:
    - Synchronous: `std::sync::mpsc` channels.
    - Async: `tokio::sync` channels (`broadcast`, `watch`, `mpsc`).
  - If using reference-based observers, use `Weak` to break cycles. Clearly document threading and ordering guarantees.

- Prototype
  - Prefer `#[derive(Clone)]`. Use `Arc` to cheaply clone shared immutable state; avoid deep copies unless semantically required.
  - Consider `Cow` to defer cloning until mutation is needed.

- Template Method
  - Prefer traits with default method hooks or higher-order functions that accept behavior via generics/closures.
  - Keep the algorithm skeleton explicit; document hook invariants and error/early-return behavior.

- Facade
  - Provide a curated, ergonomic public API via re-exports (`pub use`) and module boundaries. Hide implementation details with private fields and `pub(crate)`.
  - Offer convenience constructors and sensible defaults; keep advanced configuration behind builders and feature flags.

- Proxy
  - Implement wrapper types that satisfy the same trait and forward calls (for caching, access control, logging). Keep proxies transparent and minimally invasive.
  - Consider `Deref` only for smart-pointer-like proxies; avoid surprising implicit behavior.

- Flyweight
  - Share intrinsic state (`Arc`, interning) and pass extrinsic state as parameters. Prefer `&'static str`, `&str`, or `Cow<'_, str>` where appropriate.
  - Profile before optimizing; ensure hashing/identity semantics are well-defined if interning.

Notes
- Structural and creational patterns map well to generics and static dispatch.
- Behavioral patterns often map to trait objects or closures when heterogeneity is needed. Prefer enums + exhaustive matching when the set is closed.

## Ecosystem Integration

### Popular Crates and Patterns
- **Serialization**: `serde` with appropriate derives and custom implementations
- **Async Runtime**: `tokio` with proper feature selection
- **HTTP**: `reqwest` for clients, `axum`/`warp` for servers
- **Database**: `sqlx` for type-safe SQL, `diesel` for ORM patterns
- **CLI**: `clap` with derive API for command-line interfaces
- **Logging**: `tracing` with structured logging and proper instrumentation

### Build and Deployment
- Use multi-stage Docker builds for optimized container images
- Implement proper CI/CD with comprehensive testing and security checks
- Use `cargo-deny` for dependency auditing and license compliance
- Configure `rustfmt` and `clippy` with project-specific rules
- Use `cargo-outdated` and `cargo-audit` for dependency management

## AI Assistant Interaction Guidelines

### Effective Code Generation Requests
- Provide complete context about the problem domain and constraints
- Specify desired error handling patterns and recovery strategies
- Include integration requirements with existing code and systems
- Request comprehensive documentation and usage examples
- Ask for test implementations alongside production code

### Code Review and Iteration
- Review generated code for correctness, safety, and performance
- Validate that async patterns are used appropriately
- Ensure error handling is comprehensive and user-friendly
- Check that the code follows Rust idioms and best practices
- Verify that documentation is complete and accurate

## Checklist for AI-Generated Rust Code

- [ ] All necessary imports and module declarations included
- [ ] Proper error handling with custom error types
- [ ] Comprehensive documentation with examples
- [ ] Appropriate use of async/await patterns; avoid calling executors from sync functions (no `block_on`/ad-hoc runtimes); prefer end-to-end async and use `tokio::task::spawn_blocking` only when necessary
- [ ] Memory safety and ownership patterns correctly applied
- [ ] Type safety maintained throughout with explicit annotations
- [ ] Test coverage for critical functionality
- [ ] Security considerations addressed
- [ ] Performance implications considered
- [ ] Integration with build tools and CI/CD configured
- [ ] Proper dependency management in Cargo.toml
- [ ] Code formatted with rustfmt and linted with clippy

---

Following these practices ensures that Rust code generated with AI assistance is maintainable, performant, and follows modern Rust idioms while being optimized for development workflows with modern AI assistants.


## Source: rust/axum.md


# Axum Best Practices for AI-Assisted Development

Expert-level Axum guidance optimized for AI-assisted development workflows.
Target: Axum 0.8.4+, Tokio + Hyper + Tower stack.

## Core Principles

### AI-Friendly Development
- Generate complete context: imports, error types, state management
- Include comprehensive error handling in all generated code
- Create modular, testable components with clear boundaries
- Use explicit types and avoid implicit behaviors
- Document all public APIs with purpose and usage
- For non-trivial changes, generate or update tests alongside code, covering both success and error paths
- If the complete answer may exceed tool or model limits, propose a plan and split the work into steps before proceeding
- When requirements are ambiguous, ask one clarifying question, then proceed with a conservative, safe default

### Handler Design
- Keep handlers small, pure, async, and focused
- Return `Result<T, AppError>` consistently
- Never `unwrap` user input, network, DB, or external service results
- Validate all input before side effects
- Use structured logging with request correlation

### State Management
- Share state via `State` extractor, avoid globals
- Use `Arc` for heavy resources, cheap clones for pools/clients
- Implement `FromRef` for granular state access
- Keep `AppState` minimal and cohesive
- Use dependency injection patterns for testability

## Project Structure

```
src/
├── handlers/          # HTTP request handlers (thin layer)
├── services/          # Business logic (pure, testable)
├── repositories/      # Data access abstractions
├── middleware/        # Custom middleware components
├── types/            # DTOs, requests, responses, errors
├── config/           # Configuration management
└── tests/            # Integration and unit tests
```

## Error Handling

### Unified Error Strategy
- Create comprehensive `AppError` enum implementing `IntoResponse`
- Map database errors to appropriate HTTP status codes
- Never leak internal error details to clients
- Use structured error responses with consistent schema
- Include request correlation IDs for debugging

### Validation Patterns
- Validate at system boundaries before processing
- Use `validator` crate for declarative validation
- Sanitize input after validation
- Return meaningful error messages
- Implement custom validation for business rules

## Security Best Practices

### Authentication & Authorization
- Implement JWT-based authentication middleware
- Extract current user context for handlers
- Use role-based access control where needed
- Validate tokens properly with expiration checks
- Never store sensitive data in JWT claims

### Input Security
- Set explicit request body size limits
- Validate all path parameters and query strings
- Implement rate limiting on sensitive endpoints
- Use HTTPS in production with proper headers
- Apply CORS policies restrictively

### Security Headers
- `Strict-Transport-Security` for HTTPS enforcement
- `X-Content-Type-Options: nosniff`
- `X-Frame-Options: DENY`
- Content Security Policy for HTML responses
- Proper CORS configuration

## Performance & Scalability

### Resource Management
- Set connection pool limits for databases
- Use timeouts on all external requests
- Implement request timeouts and graceful shutdown
- Push CPU-intensive work to `spawn_blocking`
- Use streaming for large responses

### Caching Strategies
- Cache expensive computations appropriately
- Use Redis for distributed caching
- Implement cache invalidation strategies
- Consider CDN for static content
- Monitor cache hit rates

## Testing Strategy

### Comprehensive Coverage
- Unit tests for business logic in services
- Integration tests using `TestServer`
- Test both success and error paths
- Property-based testing for validation logic
- Load testing for performance validation

### Test Organization
- Create test fixtures and utilities
- Use transactional test databases
- Mock external dependencies appropriately
- Test middleware and authentication flows
- Include edge cases and error conditions

## Middleware Design

### Layer Ordering (outer to inner)
1. Request ID / Correlation
2. Tracing and logging
3. Rate limiting
4. Authentication
5. Authorization
6. CORS handling
7. Compression
8. Request timeouts

### Custom Middleware Principles
- Keep middleware focused and composable
- Use proper error handling and propagation
- Include comprehensive logging
- Make middleware testable in isolation
- Document middleware behavior clearly

## Database Integration

### Repository Pattern
- Abstract database access behind traits
- Use typed queries with compile-time validation
- Implement proper error mapping from DB to domain
- Handle connection failures gracefully
- Use transactions for multi-operation consistency

### Migration Strategy
- Version all database schema changes
- Test migrations in both directions
- Use separate migration environments
- Document breaking changes clearly
- Implement rollback procedures

## Monitoring & Observability

### Structured Logging
- Use `tracing` for all logging needs
- Include request correlation IDs
- Log at appropriate levels (error, warn, info, debug)
- Never log sensitive information
- Structure logs for machine parsing

### Metrics Collection
- Implement health check endpoints
- Track request latency and throughput
- Monitor error rates by endpoint
- Use Prometheus-compatible metrics
- Set up alerting on key indicators

## Configuration Management

### Environment-Based Config
- Use environment variables for deployment-specific settings
- Provide sensible defaults where possible
- Validate configuration at startup
- Support configuration file overrides
- Document all configuration options

### Secrets Management
- Never commit secrets to version control
- Use secure secret storage systems
- Rotate credentials regularly
- Implement least-privilege access
- Monitor secret access patterns

## Deployment Considerations

### Containerization
- Use multi-stage Docker builds
- Minimize container image size
- Run as non-root user
- Include health checks in containers
- Use distroless or minimal base images

### Graceful Shutdown
- Handle SIGTERM signals properly
- Complete in-flight requests before shutdown
- Close database connections cleanly
- Set reasonable shutdown timeouts
- Log shutdown process for debugging

## AI Assistant Guidelines

### Code Generation Requests
- Specify complete context and requirements
- Request error handling patterns upfront
- Ask for test implementations alongside code
- Include security considerations in requirements
- Request documentation for public APIs

### Review Checklist
- All handlers return proper Result types
- Comprehensive error handling implemented
- Input validation and sanitization present
- Security headers and middleware applied
- Tests cover success and failure cases
- Documentation includes usage examples
- Resource limits and timeouts configured
- Logging includes appropriate context

## Common Anti-Patterns to Avoid

- Using `unwrap`/`expect` in request handlers
- Returning raw database errors to clients
- Ignoring input validation
- Missing request timeouts and limits
- Logging sensitive information
- Using blocking operations in async handlers
- Creating overly complex middleware
- Mixing business logic in handlers
- Missing error correlation IDs
- Inadequate test coverage

## Dependency Management

### Cargo.toml Best Practices
- Specify major versions only unless fixes needed
- Use feature flags to minimize dependencies
- Regular security audits with `cargo audit`
- Keep dependencies up to date
- Document feature flag usage

### Key Dependencies
- `axum` - Web framework
- `tokio` - Async runtime
- `tower` - Middleware and services
- `sqlx` - Database integration
- `serde` - Serialization
- `tracing` - Structured logging
- `anyhow`/`thiserror` - Error handling

This document provides principles and patterns for building robust, secure, and maintainable Axum applications optimized for AI-assisted development workflows.


## Source: global/ci-and-quality.md


# CI and Quality Rules

These rules are globally applicable and model-agnostic. They set expectations for formatting, linting, testing, dependency/security hygiene, and contribution workflow that apply to any programming language or framework.

## Goals

- Make quality checks fast, deterministic, and automated.
- Fail early on formatting/linting/test issues.
- Keep dependencies healthy and secure.
- Ensure every change is reviewed, testable, and well-described.

---

## Tests-first, Always

- For any non-trivial change:
  - Write/update tests as part of the same change.
  - Include both success and error paths.
  - For regressions, add a failing test first, then fix.
- When ambiguity exists, propose a minimal plan, implement in small steps, and include tests per step.

Test execution should be:
- Fast and deterministic
- Isolated from external dependencies where possible
- Covering edge cases and error conditions
- Runnable locally and in CI

---

## Formatting and Linting

### General Principles

- Use consistent code formatting across the entire codebase.
- Automate formatting to eliminate style debates and inconsistencies.
- Configure linting rules that catch common errors and enforce best practices.
- Treat linting warnings as errors in CI to maintain code quality.

### Implementation Guidelines

- Use language-specific formatters (e.g., language built-in formatters, Prettier, Black).
- Configure linters to catch bugs, enforce conventions, and improve readability.
- Pin tool versions to ensure reproducible formatting and linting across environments.
- Fail CI builds on formatting violations or linting errors.

Local workflow:
1. Format code automatically before committing
2. Run linter and fix violations
3. Ensure tests pass

CI workflow:
1. Check formatting (non-fixing mode)
2. Run linter with error-level enforcement
3. Fail build on any violations

### Linting Policy

- Treat all linting warnings as errors in CI.
- If you must disable a rule, scope it narrowly and document the rationale.
- Prefer line-level or function-level suppressions over global disables.
- Regularly review and update linting rules as the codebase evolves.

---

## Dependency and Security Hygiene

- Keep dependency manifests (package.json, requirements.txt, Cargo.toml, etc.) and lockfiles committed and reviewed.
- Audit dependencies regularly for known vulnerabilities; CI must fail on unaddressed security issues.
- Track licenses and enforce organizational policies; CI must fail on violations.
- Keep dependencies reasonably up to date; avoid needless churn but address critical updates.

Security scanning should include:
- Known vulnerability detection
- License compliance checking
- Dependency policy enforcement (banned packages, source restrictions)
- Outdated dependency identification

Notes:
- If a security advisory cannot be addressed immediately, document a temporary exception with justification, scope, and an expiration/revisit date.
- Prefer minimal dependency graphs; remove unused dependencies.
- Use dependency pinning and lockfiles to ensure reproducible builds.

---

## Generic CI Pipeline Structure

This template can be adapted for any language/framework:

```yaml
name: CI

on:
  pull_request:
  push:
    branches: [ main ]

jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Install language runtime and tools
      - name: Setup runtime
        uses: # language-specific setup action

      # Cache dependencies and build artifacts
      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: # language-specific cache paths
          key: # language-specific cache key

      - name: Install dependencies
        run: # language-specific install command

      - name: Format check
        run: # language-specific format check command

      - name: Lint
        run: # language-specific linting command

      - name: Test
        run: # language-specific test command

      - name: Security audit
        run: # language-specific security audit command

      - name: Build
        run: # language-specific build command
```

Tips:
- Make CI fail on format/lint/test/security violations.
- Keep build times reasonable with appropriate caching.
- Run tests in parallel when possible.
- Generate test coverage reports for tracking.

---

## Pre-commit Hooks (Recommended)

Add a lightweight local workflow so obvious issues never reach CI:
1. Format code automatically
2. Run linter and fix auto-fixable issues
3. Run relevant subset of tests
4. Check for common security issues

This can be implemented via:
- Git hooks (pre-commit framework)
- Task runners (Make, Just, npm scripts)
- IDE/editor integration
- Language-specific tooling

---

## Commit Message and PR Guidance

### Commits

- Use clear, imperative subject lines (max ~72 chars).
- Keep commits focused and logically atomic.
- Reference issues when relevant.
- Conventional Commits are encouraged for automated tooling.

Examples:
- feat(api): add pagination to list endpoint
- fix(db): handle connection timeout gracefully
- refactor(auth): extract validation logic into separate module
- test(api): add error-path tests for authentication
- docs(readme): clarify local development setup
- chore(ci): enable security scanning in pipeline

### Pull Requests

- Keep PRs small and focused. If large, propose a plan and split into reviewable steps.
- PR Checklist (include in description):
  - Summary of change and rationale
  - Affected components/modules
  - Tests added/updated (success + error paths)
  - Any migration steps or breaking changes
  - Security considerations (input validation, data handling)
  - Performance considerations (if applicable)
- Include screenshots or examples for UI/behavioral changes
- Link to related issues, designs, or discussions

---

## AI Assistant Requirements (Model-agnostic)

- When proposing code changes:
  - Include the exact commands to validate (format, lint, test, security scan).
  - Generate or update tests; call out new files and why they're needed.
  - If a change is large, outline a plan and implement iteratively.
- Use proper error handling patterns appropriate for the language (no unsafe operations in production code).
- Avoid exposing sensitive information in logs, errors, or examples; redact when necessary.
- Prefer minimal diffs; for broad refactors, coordinate via plan + staged PRs.
- Follow language-specific best practices for error handling, resource management, and concurrency.

---

## Configuration Artifacts (Recommended)

Language-agnostic configuration files to maintain in the repository:
- Tool version specifications (e.g., .tool-versions, .nvmrc, runtime configuration)
- Formatter configuration files with project-specific preferences
- Linter configuration with rule customizations and justifications
- Dependency policy configuration (license allowlists, security exceptions)
- Editor configuration (.editorconfig) for consistent editing experience
- CI/CD pipeline definitions with clear stages and requirements

---

## Quality Metrics and Monitoring

Track and monitor:
- Test coverage percentages and trends
- Build success rates and duration
- Dependency vulnerability counts
- Code quality metrics (complexity, duplication)
- Review cycle times and feedback quality

Set up alerts for:
- New security vulnerabilities in dependencies
- Significant drops in test coverage
- Build failure rate increases
- Long-running or frequently failing tests

---

## Recap Checklist

- [ ] Tests added/updated for all non-trivial changes
- [ ] Code formatting is consistent and passes checks
- [ ] Linting passes with no warnings/errors
- [ ] All tests pass locally and in CI
- [ ] Security scanning shows no new vulnerabilities
- [ ] Dependency policies are satisfied
- [ ] Commit messages are clear and follow conventions
- [ ] PR description includes rationale, testing approach, and considerations
- [ ] No secrets or sensitive information exposed in code or logs
- [ ] Performance impact has been considered for critical paths

Adopting these rules ensures consistent, high-quality changes and smooth collaboration across any technology stack, whether changes are authored manually or assisted by AI models.


## Source: global/global.md


# Global AI Rules for This Workspace

These rules are model-agnostic and apply equally across different AI providers in any development environment. They define how to structure assistance, keep changes safe, and maximize developer productivity across any programming language or framework.

## Purpose
- Provide consistent, high-quality assistance across languages and stacks in this workspace.
- Keep changes safe, auditable, and reversible.
- Remain interchangeable between models without provider-specific tokens or features.

## Response Style
- Be concise by default; expand only when clarification or safety warrants it.
- Prefer straightforward, simple solutions; avoid overengineering and unnecessary abstraction.
- Prefer stepwise, incremental changes. For large tasks, propose a plan first, then implement in small, reviewable steps.
- When editing code, include complete, compilable snippets and enumerate every file to add/modify/delete.
- Default to minimal diffs. For multi-file or structural changes, outline a migration plan before code.
- When the request is ambiguous, ask one focused clarifying question, then proceed with a safe assumption if needed.

## Safety & Privacy
- Never include secrets, tokens, private keys, API keys, passwords, or personal data in prompts or outputs.
- Redact or summarize sensitive logs and configuration (e.g., env vars). Do not echo raw secrets.
- Avoid sending large or unbounded context; include only the minimum required excerpts.
- Treat any user content as potentially sensitive; anonymize examples where possible.
- If external access or network calls are relevant, explicitly note the requirement and ask for consent and configuration, rather than assuming access.

## Output Constraints and Chunking
- If an answer risks exceeding model/editor limits:
  - Propose a plan and split into numbered steps.
  - Deliver the first step, await confirmation, then continue.
- For generated code, ensure each step compiles/tests independently where feasible.

## Tests-First Policy
- For any non-trivial change:
  - Add or update tests alongside code.
  - Cover both success and error paths, including edge cases.
  - Prefer fast, deterministic tests; isolate external dependencies with interfaces/mocks.
- If adding tests is impractical in the current step, explain why and propose a follow-up test task.

## Ambiguity Handling
- Ask 1–2 targeted questions when requirements are unclear.
- If time-critical, state assumptions explicitly and choose conservative defaults.
- Document trade-offs and implications of chosen defaults.

## Provider-Agnostic Usage (Claude Sonnet 4 and GPT‑5)
- Treat both models as interchangeable. Do not rely on provider-specific prompt syntax or tool APIs.
- Heuristics (non-binding):
  - Prefer Claude Sonnet for architectural reasoning, refactors across files, and planning.
  - Prefer GPT‑5 for focused code generation, structured transformations, and schema-heavy tasks.
- If a task seems better suited to one model, state the rationale and proceed with either model unless the user requests a switch.

## Request Pattern (Repeatable Loop)
1) Analyze: restate the objective, constraints, and risks.
2) Propose: outline a short plan (steps, files, tests).
3) Implement: apply step 1 with minimal diffs and complete code/context.
4) Validate: note build/test commands to run and expected outcomes.
5) Iterate: await feedback before proceeding to next steps.

## Change Size & Diffs
- Default to the smallest viable change that solves the problem.
- Provide a file-by-file change list; when applicable, include new/removed files.
- Prefer refactors in isolation from feature changes; sequence them if both are required.

## Code Quality Defaults
- Include all necessary imports and module declarations.
- Use explicit types for public APIs and complex expressions.
- Handle errors explicitly; avoid unsafe operations or error suppression in production code.
- Add documentation comments for public APIs, constraints, and examples.
- Follow language-idiomatic style and recommended linters/formatters.

## Security Expectations
- Validate inputs at system boundaries; sanitize before use or display.
- Map internal errors to safe external responses; never leak stack traces or internals.
- Apply timeouts, rate limits, and backpressure where appropriate.
- Use least-privilege access for credentials and services.
- Provide guidance for secret management (env vars, secret stores) without embedding secrets.

## Observability & Logging
- Use structured logging and correlation/request IDs.
- Log at appropriate levels; avoid logging sensitive data.
- Suggest health checks and basic metrics for new services or endpoints.

## Documentation & Comments
- Focus documentation on developers using the corresponding code, not implementers or maintainers.
- Do not explain differences to previous versions or internals that users are not required to know about.
- Keep documentation short, simple, and informative - prioritize clarity over comprehensiveness.
- Explain "why", not just "what". Call out assumptions, trade-offs, and limitations that affect usage.
- Include practical usage examples for public functions/components showing common use cases.
- Document parameters, return values, and error conditions that callers need to handle.
- Update or create README snippets when adding meaningful features or workflows.
- Avoid implementation details unless they directly impact how the code should be used.

## IDE Integration Notes
- Optimize for navigation: consistent naming, clear module structures, and meaningful symbols for go-to-definition/find references.
- Keep imports ordered and deduplicated.
- When suggesting commands or scripts, prefer portable, single-shot commands (no long-running watchers).
- Respect file scoping: adhere to globs from specific ruleset files and keep unrelated changes out of scope.

## External Services & Commands
- Propose commands that terminate on their own (format, lint, test, build).
- For integrations (APIs, DBs), list required env vars/config and provide safe placeholders.
- Suggest migration/rollback steps where schema or contract changes occur.

## Anti-Patterns to Avoid
- Large, monolithic responses without a plan.
- Provider-specific prompt tokens or tool calls.
- Copying raw secrets, full logs, or large binary/config blobs.
- Mixing refactors with feature changes without a clear sequence.
- Omitting tests for non-trivial changes.

## Review Checklist (Quick)
- [ ] Small, incremental change with a clear plan
- [ ] Tests added/updated (success + failure paths)
- [ ] Explicit error handling; no unsafe operations in production code
- [ ] Security/privacy respected; no secrets leaked
- [ ] Minimal, complete diffs with necessary imports and docs
- [ ] Observability notes (logging/metrics) when relevant
- [ ] Commands to validate (format, lint, test, build) are provided

---
These global rules ensure consistent, safe, and efficient collaboration with AI across this workspace, while remaining fully interchangeable between Claude Sonnet 4 and GPT‑5.


## Source: global/provider-guidance.md


# Provider-Agnostic Model Guidance

This document makes the ruleset work interchangeably with different AI models in any development environment. It provides model-neutral instructions, selection guidance by task type, and response-shaping patterns that produce consistent, reviewable results regardless of the chosen provider.

## Goals and Scope

- Keep all guidance provider-agnostic: no provider-specific prompt syntax, tokens, or tool calls.
- Ensure either model can follow the same rules and yield high-quality, maintainable code.
- Define a consistent workflow: plan → implement (with tests) → validate → iterate.

## Interchangeability Principles

- Neutral formatting and behavior
  - Avoid provider-specific features or directives.
  - Keep outputs deterministic: stable ordering of imports, consistent file lists, and fixed headings.
- Safety-first defaults
  - Do not include secrets, tokens, or PII in requests or responses.
  - Summarize or redact large logs/configs; share only the minimal necessary context.
- Test-first mindset
  - For non-trivial changes, propose or include tests alongside code.
  - Prefer incremental changes with validation steps.
- Clarify ambiguity
  - If requirements are unclear, ask one targeted clarifying question, then proceed with a conservative plan.

## Model Selection by Task Type

Both models should perform well with these rules. If you have a choice, consider:

- Architecture and multi-file planning
  - Use a deliberate "analyze → plan → implement" loop for refactors, layering, domain design, or interface contracts.
- Focused code generation and transformations
  - Use for implementing a concrete function, producing minimal diffs, bulk transformations, or mechanical refactors with precise constraints.
- Mixed tasks
  - Strategy: plan (high-level) → confirm → implement (incremental) → add tests → validate.
- Fallbacks
  - If one provider is unavailable or context-limited, propose a chunking plan and proceed with the other.

Note: Keep the language model choice flexible. When uncertain, briefly propose which model to use and why (based on the task characteristics), then proceed.

## Response-Shaping Patterns

### 1) Plan → Implement Loop
- Analyze the current state and constraints.
- Propose a short plan with:
  - The files to change (paths), the type of changes, and the test updates you'll make.
  - Any risky or breaking steps explicitly called out.
- Await confirmation for multi-file or risky changes; otherwise proceed with the first step.
- Implement incrementally; after each step:
  - Provide a concise, rationale-focused summary (what changed and why) with no code blocks.
  - Do not include a changed-file list; version control tracks it.
  - Identify next steps and potential validations.

### 2) Chunking and Context Management
- If a response may exceed limits, do this:
  - Provide a concise plan and the list of affected files.
  - Implement the smallest valuable subset first (one module or feature slice).
  - Request to continue before producing additional slices.
- Prefer minimal diffs over full-file rewrites; when a full file is required (e.g., new files or fragmented context), make that explicit.

### 3) Diff vs Full-File Policy
- Default: minimal, self-contained edits that compile/run successfully.
- Full-file only when:
  - The file is new.
  - The change is sweeping and safer to present as a complete file.
  - The editor/workflow explicitly requires full file content.

### 4) Tests With Changes
- For any non-trivial code, include/update tests in the same iteration:
  - Unit tests for pure logic and individual components.
  - Integration tests for API boundaries, error cases, and system interactions.
- State how to run tests (commands) without executing them.

### 5) Error Handling and Safety Baselines
- Use language-appropriate error handling patterns:
  - Typed errors and proper error propagation.
  - Graceful degradation and fallback mechanisms.
  - Timeouts, limits, and input validation at system boundaries.
  - Structured logging with correlation IDs for traceability.
- Never expose internal system details in user-facing error messages.
- Validate all inputs at trust boundaries and sanitize before processing.

### 6) Privacy and Redaction
- Never include secrets or raw environment variables in prompts or outputs.
- Redact or summarize large or sensitive data.
- Minimize logs; provide structured, actionable summaries.

### 7) Clarifying Questions Policy
- Ask exactly one focused question when ambiguity blocks progress.
- If still uncertain after a response, propose a conservative default and proceed.

### 8) Deterministic Outputs
- Keep import ordering consistent (standard library → external dependencies → internal modules).
- Use stable wording for headings and checklists.
- Prefer explicit types, clear interfaces, and well-defined contracts.

## IDE-Oriented Tips (Model-Neutral)

- Respect ruleset scoping via globs; keep changes within the current file set unless asked otherwise.
- Include complete module context (imports, dependencies, configuration updates when relevant).
- Reference developer commands (formatting, lint, test) but do not run them; provide the exact CLI incantations.
- Default to concise responses; expand details or reasoning upon request.
- Use incremental edits that are easy to navigate with Go-to-Definition and Find References.

## Workflow Recipes

### Small Fix Flow
1) Identify root cause and risk.
2) Propose a single-file, minimal change.
3) Implement the change and a focused test.
4) Describe how to run format/lint/tests.

### Multi-File Feature Flow
1) Propose a plan: files to add/change, interfaces, tests.
2) Implement in small steps (one submodule or layer at a time).
3) Add/update tests for each step; ensure error handling is consistent.
4) Summarize next steps; pause for confirmation if crossing boundaries (API, database, build config).

### Refactor Flow
1) Inventory public APIs and call sites.
2) Propose a migration path:
   - Deprecate old API, introduce new API, create adapters if needed.
3) Apply changes incrementally with tests and clear deprecation notes.
4) Validate with lint/tests; ensure minimal impact to consumers.

### Incident/Bug Triage Flow
1) Reproduce and isolate the failing path.
2) Propose a minimal fix and a regression test.
3) Implement fix + test; add telemetry if missing.
4) Provide rollback/mitigation guidance if risk remains.

## Review Checklist (Any Model)

- Plan approved or conservative default chosen.
- Minimal diffs unless full-file is safer.
- Complete imports, types, and error handling.
- Tests included/updated for non-trivial changes.
- No secrets/PII; logs summarized/redacted.
- Performance implications considered for hot paths.
- Accessibility and security baselines respected.
- Clear run instructions (format, lint, test).
- Deterministic, consistent output formatting.

## Common Pitfalls and Mitigations

- Overlong responses → Split into steps; implement the smallest valuable subset.
- Ambiguous requirements → Ask one clarifying question; propose a safe default.
- Partial edits that don't compile/run → Include all necessary imports/types and adjust signatures.
- Leaking sensitive data → Redact early; share only what's essential.
- Hidden breaking changes → Call out risk; propose adapters/deprecations; add tests.

## Versioning and Upgrades

- Respect the project's current versions and dependency management approach.
- Propose upgrades explicitly with a short risk assessment and a test/rollback plan.
- Keep feature flags and dependency updates localized and documented.
- When looking up the latest API versions or official docs, use Context7 to fetch up-to-date documentation and version information.

## Universal Patterns for Quality Code

### Error Handling
- Use language-appropriate error handling mechanisms (exceptions, error returns, result types).
- Provide meaningful error messages that help users understand what went wrong.
- Log errors with sufficient context for debugging without exposing sensitive information.
- Implement proper cleanup and resource management in error scenarios.

### Resource Management
- Follow language-specific patterns for managing memory, file handles, network connections.
- Implement proper cleanup procedures (finally blocks, defer statements, destructors).
- Use connection pooling and resource reuse where appropriate.
- Set appropriate timeouts and limits to prevent resource exhaustion.

### Concurrency and Threading
- Use language-appropriate concurrency primitives and patterns.
- Protect shared resources with proper synchronization mechanisms.
- Avoid deadlocks through consistent ordering and timeout usage.
- Design for graceful shutdown and cancellation.

### API Design
- Follow RESTful principles for web APIs or language-specific conventions for libraries.
- Use consistent naming patterns and parameter ordering.
- Provide clear documentation and examples for public interfaces.
- Version APIs appropriately to maintain backward compatibility.

---

With these rules, different AI models can be used interchangeably in any development environment. The guidance here standardizes how tasks are planned, executed, and validated, producing consistent, safe, and reviewable results across providers and programming languages.


## Source: global/readme-structure.md


# README Structure and Content Rules for AI-Assisted Development

## Purpose
Define standards for creating comprehensive, user-friendly README.md files that effectively communicate project purpose, usage, and contribution guidelines to users and developers.

## Essential README Sections

### Project Header Requirements
- Start with clear, descriptive project title as H1 heading
- Include concise one-line description immediately after title
- Add detailed project purpose and goals in following paragraph
- Place badges (build status, version, license) after description if applicable

### Installation Section Standards
- Provide complete prerequisites list with version requirements
- Include step-by-step installation instructions
- Add platform-specific guidance when needed
- Show actual commands users should run (npm install, pip install, etc.)
- Test all installation commands before including them

### Usage Examples Requirements
- Include basic usage example that users can run immediately
- Provide complete, working code snippets with proper syntax highlighting
- Show expected output where helpful
- Include common use cases and workflows
- Add configuration options with examples

### Documentation Structure
- Use consistent heading hierarchy (H1 for title, H2 for main sections, H3 for subsections)
- Include table of contents for READMEs longer than 200 lines
- Link to external documentation when available
- Provide API reference or quick reference section for libraries

## Code Example Standards

### Code Block Requirements
- Use proper language tags for syntax highlighting
- Provide complete, runnable examples that work out of the box
- Include necessary imports and setup code
- Show realistic data and scenarios, not placeholder text
- Test all code examples before including them

### Example Code Patterns
```bash
# Good: Complete, tested command
npm install package-name --save
npm run build
```

```javascript
// Good: Complete example with imports and realistic usage
const express = require('express');
const app = express();

app.get('/api/users', (req, res) => {
  res.json({ users: ['alice', 'bob'] });
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

### Anti-Patterns to Avoid
- ❌ Incomplete code snippets without imports or context
- ❌ Placeholder text like "your-api-key-here" without explanation
- ❌ Commands that don't actually work as written
- ❌ Examples using deprecated or outdated syntax

## Project Type Specific Guidelines

### Library/Package Documentation
- Emphasize installation and basic usage heavily
- Include comprehensive API documentation or links
- Show integration examples with popular frameworks
- Document all public methods, functions, or classes
- Include troubleshooting section for common issues

### Application Documentation
- Include screenshots or demo links prominently
- Provide deployment and configuration instructions
- Document environment variables and settings
- Show different usage scenarios or user workflows
- Include system requirements and dependencies

### CLI Tool Documentation
- Show command examples with actual output
- Document all available flags and options with descriptions
- Include usage scenarios and common workflows
- Provide installation verification commands
- Add troubleshooting for common CLI issues

## Contributing and Community Sections

### Contributing Guidelines Requirements
- Explain how to report bugs with issue template links
- Provide development environment setup instructions
- Document coding standards and style guidelines
- Explain pull request process and requirements
- Include testing requirements and how to run tests

### Community Information Standards
- Include license information with link to full text
- Add code of conduct reference for open source projects
- Credit major contributors and acknowledgments
- Provide contact information or community links
- Include security policy reference if applicable

## Quality Assurance Standards

### Content Verification Requirements
- Test all installation instructions on clean environment
- Verify all code examples compile and run correctly
- Check all links are accessible and current
- Ensure consistent formatting and style throughout
- Update examples when dependencies or APIs change

### Maintenance Guidelines
- Keep README current with project changes
- Update version numbers and compatibility information
- Refresh screenshots and demo links regularly
- Review and update contributing guidelines periodically
- Maintain consistency with actual project behavior

## AI Assistant Interaction Guidelines

### Effective README Creation Requests
When requesting README assistance:
- Specify project type (library, application, CLI tool, etc.)
- Mention target audience (beginners, developers, specific domain)
- Include existing project structure and key files
- Specify any special requirements or constraints

### Iterative README Development
- Start with essential sections (title, description, installation, basic usage)
- Add comprehensive examples and documentation iteratively
- Refine based on user feedback and common questions
- Test README effectiveness with new users when possible

### README Review Process
When reviewing generated READMEs:
- Verify all code examples work as written
- Check that installation instructions are complete and accurate
- Ensure appropriate depth for target audience
- Confirm consistent formatting and professional presentation

## Content Organization Patterns

### Information Hierarchy
Structure information by user journey:
1. **Discovery**: Title, description, key features
2. **Evaluation**: Screenshots, demos, comparison with alternatives
3. **Getting Started**: Installation, basic usage, quick start guide
4. **Learning**: Detailed examples, tutorials, best practices
5. **Reference**: API documentation, configuration options, troubleshooting
6. **Contributing**: Development setup, contribution guidelines, community info

### Section Ordering Standards
- Place most critical information first (installation, basic usage)
- Group related information together (all usage examples in one section)
- End with community and contribution information
- Use consistent section naming across projects

## Formatting and Style Guidelines

### Markdown Best Practices
- Use consistent heading styles and hierarchy
- Include blank lines around code blocks and sections
- Use proper list formatting with consistent indentation
- Include alt text for images and meaningful link text
- Test markdown rendering in target platforms (GitHub, GitLab, etc.)

### Visual Design Principles
- Use whitespace effectively to improve readability
- Include visual breaks between major sections
- Use code blocks, quotes, and emphasis strategically
- Keep line length reasonable for easy reading
- Ensure good contrast and accessibility

## Checklist for README Quality

**Essential Content:**
- [ ] Clear project title and description
- [ ] Complete installation instructions tested on clean system
- [ ] Working basic usage example that new users can run
- [ ] Link to additional documentation or resources
- [ ] License and contributing information

**Code Examples:**
- [ ] All code examples tested and working
- [ ] Proper syntax highlighting applied
- [ ] Complete examples with necessary imports and setup
- [ ] Realistic data and scenarios used
- [ ] Expected output shown where helpful

**Organization and Style:**
- [ ] Logical information flow matching user journey
- [ ] Consistent formatting and markdown style
- [ ] Appropriate section depth for target audience
- [ ] Professional presentation and tone
- [ ] All links verified and accessible

**Maintenance Considerations:**
- [ ] Version information current and accurate
- [ ] Examples compatible with documented versions
- [ ] Screenshots and demos reflect current state
- [ ] Contributing guidelines match actual process
- [ ] Contact and community information up to date

## Anti-Patterns in README Creation

**Avoid These Common Mistakes:**

**❌ Incomplete Installation Instructions:**
```markdown
# Too vague
## Installation
Just install the dependencies and run it.
```

**❌ Non-Working Code Examples:**
```python
# Missing imports, won't actually run
result = awesome_function("test")
print(result)
```

**❌ Overwhelming Wall of Text:**
```markdown
# No structure or breathing room
This project does many things and here's everything about it in one giant paragraph that goes on and on without any breaks or organization making it very difficult to scan and find specific information that users need when they're trying to understand what this project does and how to use it...
```

**❌ Outdated or Incorrect Information:**
```markdown
# Information that doesn't match current project state
This project requires Node.js 8+ (when it actually requires Node.js 16+)
Run `npm start` to begin (when the actual command is `npm run dev`)
```

**❌ Missing Critical Information:**
```markdown
# Assumes too much knowledge
## Usage
Configure the settings and run the application.
```

---

Following these rules ensures README files serve as effective project documentation that welcomes new users, provides clear guidance, and maintains professional standards across different project types and audiences.


## Source: global/security-ai.md


# AI Security & Privacy Rules (Global)

Model-agnostic rules to keep code, data, and credentials safe while collaborating with AI in any development environment. These rules apply to all files matched by this ruleset.

## Golden rules

- Never include secrets or raw PII in prompts, responses, diffs, or logs.
- Minimize context: share only what is strictly necessary to solve the task.
- Redact before sharing; use deterministic placeholders (e.g., "<REDACTED:API_KEY>").
- Ask for consent before any external network/API calls or uploads.
- Prefer synthetic/fake data and least-privilege design patterns.

## Definitions

- Secrets: API keys, tokens, passwords, private keys, client secrets, credentials, connection strings, session cookies, JWTs, cloud access keys, SSH keys, encryption keys.
- PII: Any data that can identify a person (name, email, phone, address, identifiers, IPs when tied to identity, device IDs). Treat "quasi-identifiers" as PII when combined (e.g., ZIP + birth date).
- Sensitive business data: Proprietary code, unreleased features, financial, legal, or security configurations.
- Safety-critical code: Authentication, authorization, cryptography, payment processing, personal/medical data handlers.

## Default assistant behavior

- Minimize shared content: summarize large logs/configs; share only the essential lines and structure.
- Prefer references over raw values (e.g., "uses environment variable DATABASE_PASSWORD" instead of actual value).
- Redact with explicit, typed placeholders:
  - "<REDACTED:API_KEY>", "<REDACTED:JWT>", "<REDACTED:ACCESS_TOKEN>", "<REDACTED:EMAIL>", "<REDACTED:PHONE>"
- Truncate long values (e.g., "sk_live_…<TRUNCATED>") after first 6–8 visible chars when context is necessary.
- Avoid echoing environment variables, configuration file contents, or credentials. If absolutely necessary, include only variable names and sample placeholders.
- If uncertain whether data is sensitive, treat it as sensitive and ask one clarifying question.

## Secrets and credential hygiene

- Do not generate real credentials. Use placeholders and provide guidance to create and store secrets securely.
- Suggest maintaining sample configuration files with placeholders and ensuring actual configuration files are ignored by version control.
- Never print secrets in logs, errors, or test output. Use masked forms or placeholders.
- Recommend rotation if a secret appears in code, history, logs, or discussion.
- Avoid embedding credentials in URLs or source code; use environment variables or secret managers.
- For token-like strings, always redact before quoting or copying.

## PII handling

- Default to data minimization: avoid including real names, emails, or IDs.
- Use synthetic/fake data for examples (e.g., "Jane Doe", "jane@example.com", "+1-202-555-0100").
- Pseudonymize when troubleshooting (e.g., "User A", "Order #1234").
- Never post raw datasets, CSVs, or logs containing PII; provide schemas, small fake samples, or summaries.
- For analytics or telemetry examples, aggregate or hash identifiers; avoid unique raw identifiers when not needed.

## Logging and tracing

- Prefer structured, minimal logs: event name, correlation/request ID, high-level error category.
- Avoid logging secrets, tokens, full headers, or entire request/response bodies.
- Cap log sizes, fields, and arrays; omit or hash large or sensitive fields.
- Return safe error responses to clients (no internal stack traces or configuration details).
- Use correlation IDs for tracing instead of duplicating user or sensitive identifiers.

## External calls, uploads, and tooling

- Obtain explicit consent before:
  - Calling external APIs or services.
  - Uploading files/snippets to third-party endpoints.
  - Using remote code execution, package queries, or automated fetchers.
- When proposing an external call, specify:
  - Endpoint, purpose, and expected benefit.
  - Data categories involved (e.g., metadata only, no PII/secrets).
  - Data minimization strategy (masking, sampling).
  - Alternatives if external calls are disallowed.
- Respect organizational constraints (proxies, allowlists, approval workflows). If unknown, assume restricted and ask.

## Compliance guidance (non-exhaustive, not legal advice)

- GDPR/CCPA: minimize personal data; provide deletion/anonymization paths; log only what is necessary.
- HIPAA: treat PHI as highly restricted; avoid sharing; use de-identified data for examples.
- PCI-DSS: never handle raw payment card data in logs or code snippets; use tokenization.
- SOC 2: prefer least-privilege, auditing, change control; avoid uncontrolled data egress.
- If a change could impact compliance, flag it and recommend review by security/privacy stakeholders.

## Source code and licensing

- Avoid pasting large third-party code blocks; link, summarize, or cite instead.
- Respect licenses; avoid incorporating incompatible-licensed code into proprietary repositories.
- Recommend license and vulnerability checks for dependencies; keep audit findings out of public contexts.

## Data classification defaults

- Treat repository content as Confidential by default.
- Assume external sharing is prohibited unless explicitly approved.
- If classification is unclear, ask for confirmation and proceed with the most restrictive assumption.

## Incident handling (suspected exposure)

- Stop propagation: do not repeat or further disseminate sensitive content.
- Summarize minimally what was exposed (type, scope, time) without repeating the data.
- Recommend immediate actions: rotate keys, revoke tokens, invalidate sessions, purge caches.
- Suggest notifying the responsible security/contact channel with minimal necessary details.

## Review checklist (apply before posting responses)

- [ ] No secrets, tokens, or credentials included.
- [ ] No raw PII; synthetic or redacted data only.
- [ ] Logs/configs minimized; only essential lines included.
- [ ] Any proposed external call includes purpose, minimization, and consent request.
- [ ] Error messages safe; no internal details leaked.
- [ ] Test data uses fakes; no production samples.
- [ ] Licensing respected; no large third-party code pasted.
- [ ] Recommendations include secret rotation if exposure suspected.
- [ ] Compliance-sensitive areas flagged when relevant.
- [ ] The least-privilege and data-minimization principles are followed.

## Safe example patterns (non-executable)

- Environment variables: show names only (e.g., "DATABASE_USER", "DATABASE_PASSWORD") with placeholder values.
- Credentials in URLs: never include; show pattern "database://USER:PASSWORD@host/dbname" with clear placeholders.
- JWTs, session cookies: show as "<REDACTED:JWT>" or "sessionid=…<TRUNCATED>".
- Logs: log event codes and correlation IDs; omit payloads unless strictly necessary and sanitized.

## Opt-in templates

Use these templates to align requests/responses with safe practices.

- Redaction acknowledgment:
  - "Detected sensitive content (type: API key). Redacting and proceeding with a minimal, masked example. Recommend rotating the affected credential and updating secrets storage."

- External call consent request:
  - "To fetch X, propose calling Y (method: GET, scope: metadata only, no PII, no secrets). I will mask identifiers and share only necessary headers. Proceed?"

## What to do when in doubt

- Ask one focused clarifying question, propose the safest default, then proceed minimally.
- Prefer a plan-first approach for large contexts or ambiguous requirements.
- Stop and flag to stakeholders if continuing might cause data exposure.

## Language-agnostic security patterns

- Input validation: Validate all inputs at trust boundaries using allow-lists rather than deny-lists.
- Output encoding: Properly encode data based on the output context (HTML, SQL, shell commands).
- Authentication: Use strong authentication mechanisms and multi-factor authentication where possible.
- Authorization: Implement least-privilege access controls and regularly review permissions.
- Cryptography: Use well-established libraries and algorithms; never implement custom crypto.
- Session management: Use secure session handling with proper timeout and invalidation.
- Error handling: Fail securely; don't leak sensitive information in error messages.
- Logging: Log security events for monitoring but never log sensitive data.

---
By following these rules, assistants and contributors maintain strong security posture across models and workflows while enabling effective, privacy-preserving collaboration in any development environment regardless of the programming language or technology stack being used.

