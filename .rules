---
description: Combined AI ruleset (model-agnostic) for Zed; aggregated from ai-ruleset/src categories: rust global. Generated by build.sh.
globs: "**/*"
---

# AI Ruleset (Combined)

_This file is generated. Do not edit manually. Sources: ai-ruleset/src/{rust,global}/_


## Source: rust/rust.md

# Rust Best Practices for AI-Assisted Development

You are an expert in Rust programming and related technologies, optimized for AI-assisted development workflows using Zed editor, Claude Sonnet 4, and GPT-5.

## AI-Optimized Development Principles

### Context-Aware Code Generation
- Always provide complete module context including all necessary imports (`use` statements)
- Include relevant configuration files (Cargo.toml, .cargo/config.toml) when generating projects
- Generate complete function signatures with proper parameters, return types, lifetimes, and bounds
- Include comprehensive documentation comments (`///`) explaining purpose, parameters, examples, and safety considerations
- Provide context about the module's role in the larger system architecture
- Follow proper module organization and crate structure with clear dependency graphs
- Include error handling context and propagation patterns
- Specify trait bounds and generic constraints explicitly
- For any non-trivial change, generate or update tests alongside code (unit and/or integration), covering both success and error paths
- If the complete answer may exceed tool or model limits, propose a plan and split the work into steps
- When requirements are ambiguous, ask one clarifying question, then proceed with a conservative, safe default

### Zed Editor Integration
- Structure code for optimal Go-to-Definition and Find References functionality
- Use consistent naming conventions that support fuzzy finding and navigation
- Organize imports in standard order: std, external crates, local crates, modules
- Implement proper rust-analyzer integration with meaningful symbols
- Use explicit type annotations for complex expressions to improve IDE experience
- Structure projects with clear module hierarchies for better code navigation
- Configure workspace settings for optimal Rust development experience

## Modern Rust Patterns and Idioms

### Type System Excellence
- Leverage the type system to encode invariants and prevent runtime errors
- Use newtype patterns to create domain-specific types with clear semantics
- Implement proper trait design with associated types and generic parameters
- Use const generics for compile-time parameterization where appropriate
- Implement proper error types with thiserror or custom error enums
- Use phantom types and zero-sized types for compile-time guarantees
- Leverage type-level programming with const assertions where beneficial

### Memory Management and Performance
- Follow ownership patterns: prefer owned types, borrow when necessary
- Use `Cow<'_, T>` for flexible ownership in APIs that might clone
- Implement proper lifetime management with explicit annotations when needed
- Use `Arc` and `Rc` judiciously for shared ownership scenarios
- Prefer `Arc::clone(&variable)` over `variable.clone()` for explicit semantic clarity when cloning reference-counted types
- Prefer stack allocation; use heap allocation (`Box`, `Vec`) when size is dynamic
- Use `Pin` and `Unpin` correctly for self-referential structures
- Implement zero-cost abstractions with proper inlining and generic specialization
- Profile and optimize hot paths with appropriate benchmarking

### Error Handling Patterns
- Create comprehensive custom error types using `thiserror` or manual implementations
- Use `Result<T, E>` consistently; never use `unwrap()` or `expect()` in production code (permitted only in test code, e.g., within `#[cfg(test)]` modules or test crates). Avoid panicking in library or application code; prefer typed errors and proper propagation
- Implement proper error propagation with `?` operator and custom `From` implementations
- Use `anyhow` for application-level error handling with context
- Implement graceful degradation patterns for non-critical failures
- Create error hierarchies that provide useful debugging information
- Use `tracing` for structured error logging with proper context

## Code Organization and Architecture

### Project Structure
```
src/
├── lib.rs              # Crate root with public API
├── bin/                # Binary targets
│   └── main.rs
├── config/             # Configuration management
│   ├── mod.rs
│   └── settings.rs
├── domain/             # Domain models and business logic
│   ├── mod.rs
│   ├── entities/       # Domain entities
│   ├── services/       # Business services
│   └── repositories/   # Data access abstractions
├── infrastructure/     # External integrations
│   ├── mod.rs
│   ├── database/
│   ├── http_client/
│   └── messaging/
├── api/                # API layer (REST, GraphQL, gRPC)
│   ├── mod.rs
│   ├── handlers/
│   ├── middleware/
│   └── routing/
├── utils/              # Utility functions and helpers
│   ├── mod.rs
│   └── validation.rs
└── tests/              # Integration tests
    └── common/
        └── mod.rs
```

### Module Design Principles
- Design modules with clear, single responsibilities
- Create stable public APIs with semantic versioning considerations
- Use `pub(crate)` for internal APIs that shouldn't be exposed
- Implement proper module documentation with usage examples
- Design for testability with dependency injection patterns
- Create clear boundaries between layers (domain, infrastructure, API)

### Dependency Management
```toml
# Cargo.toml - Specify only major versions unless specific fixes needed
[dependencies]
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
tracing = "0.1"
anyhow = "1"
thiserror = "1"

[dev-dependencies]
tokio-test = "0.4"
criterion = "0.5"
proptest = "1"
```

## Async Programming Excellence

### Modern Async Patterns
- Use `async`/`await` consistently; avoid blocking operations in async contexts; prefer end-to-end async instead of running async code from sync functions via executors (no `block_on`, no ad-hoc runtimes). Use `tokio::task::spawn_blocking` only when truly necessary to isolate unavoidable blocking work.
- Implement proper async trait patterns with `async-trait` when needed
- Use `tokio::task::spawn_blocking` for CPU-intensive or blocking operations
- Implement proper stream processing with `futures::Stream` and async iterators
- Use `tokio::select!` for concurrent operations with cancellation
- Implement proper async error handling with context preservation
- Use async-friendly data structures and synchronization primitives

### Concurrency and Parallelism
- Choose appropriate synchronization primitives (Mutex, RwLock, Semaphore)
- Use message passing with channels (`mpsc`, `broadcast`, `watch`) when appropriate
- Implement proper backpressure handling in streaming scenarios
- Use `Arc` for shared state in multi-threaded contexts
- Implement graceful shutdown patterns for long-running services
- Use work-stealing executors appropriately for different workloads

## Testing and Quality Assurance

### Comprehensive Testing Strategy
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tokio_test;
    use proptest::prelude::*;

    #[tokio::test]
    async fn test_async_operation() {
        // Test async operations with proper setup/teardown
    }

    proptest! {
        #[test]
        fn test_property_based(input: Vec<u32>) {
            // Property-based testing for edge cases
        }
    }

    #[test]
    fn test_unit_functionality() {
        // Unit tests with clear arrange/act/assert structure
    }
}
```

### Test Organization
- Write unit tests for individual functions and methods
- Create integration tests in the `tests/` directory
- Use property-based testing with `proptest` for comprehensive coverage
- Implement benchmark tests with `criterion` for performance validation
- Create test utilities and fixtures for common test scenarios
- Mock external dependencies with appropriate test doubles
- Test error conditions and edge cases thoroughly

## Security and Safety

### Memory Safety
- Leverage Rust's ownership system to prevent memory safety issues
- Use `unsafe` code sparingly and document safety invariants clearly
- Implement proper bounds checking and validation for all inputs
- Use safe abstractions over unsafe operations when possible
- Audit unsafe code blocks with clear safety documentation

### Input Validation and Sanitization
```rust
use serde::{Deserialize, Serialize};
use validator::{Validate, ValidationError};

#[derive(Debug, Deserialize, Validate)]
pub struct UserInput {
    #[validate(length(min = 1, max = 100))]
    pub name: String,
    
    #[validate(email)]
    pub email: String,
    
    #[validate(range(min = 18, max = 120))]
    pub age: u8,
}

impl UserInput {
    pub fn validate_and_sanitize(self) -> Result<ValidatedUserInput, ValidationError> {
        self.validate()?;
        Ok(ValidatedUserInput {
            name: self.name.trim().to_string(),
            email: self.email.to_lowercase(),
            age: self.age,
        })
    }
}
```

### Security Best Practices
- Validate all external input at system boundaries
- Use secure random number generation with `rand::thread_rng()`
- Implement proper authentication and authorization patterns
- Use secure serialization formats and validate deserialized data
- Handle secrets securely without logging sensitive information
- Implement rate limiting and request throttling mechanisms

## Performance Optimization

### Profiling and Benchmarking
```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn benchmark_function(c: &mut Criterion) {
    c.bench_function("operation", |b| {
        b.iter(|| {
            black_box(expensive_operation(black_box(input_data())))
        })
    });
}

criterion_group!(benches, benchmark_function);
criterion_main!(benches);
```

### Optimization Strategies
- Profile before optimizing using `cargo flamegraph` or `perf`
- Use appropriate data structures for the access patterns
- Implement lazy evaluation patterns where beneficial
- Use `const` functions and const evaluation for compile-time computation
- Optimize allocations by reusing buffers and using object pools
- Use SIMD operations through portable abstractions when appropriate

## Documentation and Maintenance

### Comprehensive Documentation
```rust
/// Processes user data with validation and transformation.
///
/// # Arguments
///
/// * `input` - Raw user input requiring validation
/// * `config` - Processing configuration options
///
/// # Returns
///
/// Returns a `Result` containing processed data or validation errors.
///
/// # Examples
///
/// ```rust
/// use myapp::{UserInput, Config, process_user_data};
///
/// let input = UserInput::new("John", "john@example.com");
/// let config = Config::default();
/// let result = process_user_data(input, &config)?;
/// ```
///
/// # Errors
///
/// This function returns an error if:
/// - Input validation fails
/// - External service is unavailable
/// - Processing constraints are violated
pub async fn process_user_data(
    input: UserInput,
    config: &Config,
) -> Result<ProcessedData, ProcessingError> {
    // Implementation
}
```

### Maintenance Patterns
- Do not change crate-level attributes (e.g., `#![deny(missing_docs)]`, `clippy::all`, or other `warn`/`allow`/`deny` settings) without explicit confirmation. By default, changes are prohibited. If a change is explicitly approved, use the narrowest possible `#[allow(...)]` with a clear justification, and prefer scoping to test-only code via `#[cfg(test)]`.
- Use `#[deprecated]` attributes with migration guidance for API changes
- Implement feature flags with `cfg` attributes for experimental features
- Create changelog entries following semantic versioning principles
- Use cargo workspaces for multi-crate projects with shared dependencies
- Implement proper CI/CD pipelines with comprehensive checks

## AI-Friendly Code Patterns

### Explicit Context Provision
- Include all necessary imports and module declarations
- Provide complete function signatures with explicit types
- Include comprehensive error types and handling patterns
- Document all public APIs with examples and constraints
- Structure code with clear separation of concerns

### Maintainable Abstractions
```rust
// Good: Clear trait with documented behavior
pub trait UserRepository {
    type Error: std::error::Error + Send + Sync + 'static;
    
    /// Finds a user by their unique identifier.
    /// Returns None if no user exists with the given ID.
    async fn find_by_id(&self, id: UserId) -> Result<Option<User>, Self::Error>;
    
    /// Saves a user, creating or updating as needed.
    /// Returns the saved user with any generated fields populated.
    async fn save(&self, user: User) -> Result<User, Self::Error>;
}

// Implementation with proper error handling
#[derive(Debug, thiserror::Error)]
pub enum DatabaseError {
    #[error("Connection failed: {0}")]
    Connection(#[from] sqlx::Error),
    
    #[error("Validation failed: {message}")]
    Validation { message: String },
    
    #[error("Resource not found: {resource_type} with id {id}")]
    NotFound { resource_type: String, id: String },
}
```

## Advanced Patterns and Techniques

### Macro Design
- Create declarative macros that generate boilerplate code
- Use procedural macros for compile-time code generation
- Follow macro hygiene principles to avoid name collisions
- Provide clear error messages for macro usage errors
- Document macro usage with comprehensive examples

### Generic Programming
- Design generic APIs that work with multiple types
- Use associated types appropriately for cleaner APIs
- Implement proper trait bounds with where clauses
- Use higher-ranked trait bounds (HRTB) when needed for lifetime polymorphism
- Create type-level computations with const generics

### Foreign Function Interface (FFI)
- Design safe Rust wrappers around unsafe FFI functions
- Use proper memory management across language boundaries
- Implement proper error handling for FFI operations
- Document safety requirements and invariants clearly
- Use `bindgen` for automatic binding generation when appropriate

## Ecosystem Integration

### Popular Crates and Patterns
- **Serialization**: `serde` with appropriate derives and custom implementations
- **Async Runtime**: `tokio` with proper feature selection
- **HTTP**: `reqwest` for clients, `axum`/`warp` for servers
- **Database**: `sqlx` for type-safe SQL, `diesel` for ORM patterns
- **CLI**: `clap` with derive API for command-line interfaces
- **Logging**: `tracing` with structured logging and proper instrumentation

### Build and Deployment
- Use multi-stage Docker builds for optimized container images
- Implement proper CI/CD with comprehensive testing and security checks
- Use `cargo-deny` for dependency auditing and license compliance
- Configure `rustfmt` and `clippy` with project-specific rules
- Use `cargo-outdated` and `cargo-audit` for dependency management

## AI Assistant Interaction Guidelines

### Effective Code Generation Requests
- Provide complete context about the problem domain and constraints
- Specify desired error handling patterns and recovery strategies
- Include integration requirements with existing code and systems
- Request comprehensive documentation and usage examples
- Ask for test implementations alongside production code

### Code Review and Iteration
- Review generated code for correctness, safety, and performance
- Validate that async patterns are used appropriately
- Ensure error handling is comprehensive and user-friendly
- Check that the code follows Rust idioms and best practices
- Verify that documentation is complete and accurate

## Checklist for AI-Generated Rust Code

- [ ] All necessary imports and module declarations included
- [ ] Proper error handling with custom error types
- [ ] Comprehensive documentation with examples
- [ ] Appropriate use of async/await patterns; avoid calling executors from sync functions (no `block_on`/ad-hoc runtimes); prefer end-to-end async and use `tokio::task::spawn_blocking` only when necessary
- [ ] Memory safety and ownership patterns correctly applied
- [ ] Type safety maintained throughout with explicit annotations
- [ ] Test coverage for critical functionality
- [ ] Security considerations addressed
- [ ] Performance implications considered
- [ ] Integration with build tools and CI/CD configured
- [ ] Proper dependency management in Cargo.toml
- [ ] Code formatted with rustfmt and linted with clippy

---

Following these practices ensures that Rust code generated with AI assistance is maintainable, performant, and follows modern Rust idioms while being optimized for development workflows using Zed editor and AI assistants like Claude Sonnet 4 and GPT-5.


## Source: rust/axum.md


# Axum Best Practices for AI-Assisted Development

Optimized for Zed editor, Claude Sonnet 4, and GPT-5 workflows.
Target: Axum 0.8.4+, Tokio + Hyper + Tower stack.

## Core Principles

### AI-Friendly Development
- Generate complete context: imports, error types, state management
- Include comprehensive error handling in all generated code
- Create modular, testable components with clear boundaries
- Use explicit types and avoid implicit behaviors
- Document all public APIs with purpose and usage
- For non-trivial changes, generate or update tests alongside code, covering both success and error paths
- If the complete answer may exceed tool or model limits, propose a plan and split the work into steps before proceeding
- When requirements are ambiguous, ask one clarifying question, then proceed with a conservative, safe default

### Handler Design
- Keep handlers small, pure, async, and focused
- Return `Result<T, AppError>` consistently
- Never `unwrap` user input, network, DB, or external service results
- Validate all input before side effects
- Use structured logging with request correlation

### State Management
- Share state via `State` extractor, avoid globals
- Use `Arc` for heavy resources, cheap clones for pools/clients
- Implement `FromRef` for granular state access
- Keep `AppState` minimal and cohesive
- Use dependency injection patterns for testability

## Project Structure

```
src/
├── handlers/          # HTTP request handlers (thin layer)
├── services/          # Business logic (pure, testable)
├── repositories/      # Data access abstractions
├── middleware/        # Custom middleware components
├── types/            # DTOs, requests, responses, errors
├── config/           # Configuration management
└── tests/            # Integration and unit tests
```

## Error Handling

### Unified Error Strategy
- Create comprehensive `AppError` enum implementing `IntoResponse`
- Map database errors to appropriate HTTP status codes
- Never leak internal error details to clients
- Use structured error responses with consistent schema
- Include request correlation IDs for debugging

### Validation Patterns
- Validate at system boundaries before processing
- Use `validator` crate for declarative validation
- Sanitize input after validation
- Return meaningful error messages
- Implement custom validation for business rules

## Security Best Practices

### Authentication & Authorization
- Implement JWT-based authentication middleware
- Extract current user context for handlers
- Use role-based access control where needed
- Validate tokens properly with expiration checks
- Never store sensitive data in JWT claims

### Input Security
- Set explicit request body size limits
- Validate all path parameters and query strings
- Implement rate limiting on sensitive endpoints
- Use HTTPS in production with proper headers
- Apply CORS policies restrictively

### Security Headers
- `Strict-Transport-Security` for HTTPS enforcement
- `X-Content-Type-Options: nosniff`
- `X-Frame-Options: DENY`
- Content Security Policy for HTML responses
- Proper CORS configuration

## Performance & Scalability

### Resource Management
- Set connection pool limits for databases
- Use timeouts on all external requests
- Implement request timeouts and graceful shutdown
- Push CPU-intensive work to `spawn_blocking`
- Use streaming for large responses

### Caching Strategies
- Cache expensive computations appropriately
- Use Redis for distributed caching
- Implement cache invalidation strategies
- Consider CDN for static content
- Monitor cache hit rates

## Testing Strategy

### Comprehensive Coverage
- Unit tests for business logic in services
- Integration tests using `TestServer`
- Test both success and error paths
- Property-based testing for validation logic
- Load testing for performance validation

### Test Organization
- Create test fixtures and utilities
- Use transactional test databases
- Mock external dependencies appropriately
- Test middleware and authentication flows
- Include edge cases and error conditions

## Middleware Design

### Layer Ordering (outer to inner)
1. Request ID / Correlation
2. Tracing and logging
3. Rate limiting
4. Authentication
5. Authorization
6. CORS handling
7. Compression
8. Request timeouts

### Custom Middleware Principles
- Keep middleware focused and composable
- Use proper error handling and propagation
- Include comprehensive logging
- Make middleware testable in isolation
- Document middleware behavior clearly

## Database Integration

### Repository Pattern
- Abstract database access behind traits
- Use typed queries with compile-time validation
- Implement proper error mapping from DB to domain
- Handle connection failures gracefully
- Use transactions for multi-operation consistency

### Migration Strategy
- Version all database schema changes
- Test migrations in both directions
- Use separate migration environments
- Document breaking changes clearly
- Implement rollback procedures

## Monitoring & Observability

### Structured Logging
- Use `tracing` for all logging needs
- Include request correlation IDs
- Log at appropriate levels (error, warn, info, debug)
- Never log sensitive information
- Structure logs for machine parsing

### Metrics Collection
- Implement health check endpoints
- Track request latency and throughput
- Monitor error rates by endpoint
- Use Prometheus-compatible metrics
- Set up alerting on key indicators

## Configuration Management

### Environment-Based Config
- Use environment variables for deployment-specific settings
- Provide sensible defaults where possible
- Validate configuration at startup
- Support configuration file overrides
- Document all configuration options

### Secrets Management
- Never commit secrets to version control
- Use secure secret storage systems
- Rotate credentials regularly
- Implement least-privilege access
- Monitor secret access patterns

## Deployment Considerations

### Containerization
- Use multi-stage Docker builds
- Minimize container image size
- Run as non-root user
- Include health checks in containers
- Use distroless or minimal base images

### Graceful Shutdown
- Handle SIGTERM signals properly
- Complete in-flight requests before shutdown
- Close database connections cleanly
- Set reasonable shutdown timeouts
- Log shutdown process for debugging

## AI Assistant Guidelines

### Code Generation Requests
- Specify complete context and requirements
- Request error handling patterns upfront
- Ask for test implementations alongside code
- Include security considerations in requirements
- Request documentation for public APIs

### Review Checklist
- All handlers return proper Result types
- Comprehensive error handling implemented
- Input validation and sanitization present
- Security headers and middleware applied
- Tests cover success and failure cases
- Documentation includes usage examples
- Resource limits and timeouts configured
- Logging includes appropriate context

## Common Anti-Patterns to Avoid

- Using `unwrap`/`expect` in request handlers
- Returning raw database errors to clients
- Ignoring input validation
- Missing request timeouts and limits
- Logging sensitive information
- Using blocking operations in async handlers
- Creating overly complex middleware
- Mixing business logic in handlers
- Missing error correlation IDs
- Inadequate test coverage

## Dependency Management

### Cargo.toml Best Practices
- Specify major versions only unless fixes needed
- Use feature flags to minimize dependencies
- Regular security audits with `cargo audit`
- Keep dependencies up to date
- Document feature flag usage

### Key Dependencies
- `axum` - Web framework
- `tokio` - Async runtime
- `tower` - Middleware and services
- `sqlx` - Database integration
- `serde` - Serialization
- `tracing` - Structured logging
- `anyhow`/`thiserror` - Error handling

This document provides principles and patterns for building robust, secure, and maintainable Axum applications optimized for AI-assisted development workflows.


## Source: global/ci-and-quality.md


# CI and Quality Rules

These rules are globally applicable and model-agnostic. They set expectations for formatting, linting, testing, dependency/security hygiene, and contribution workflow. They are intended to be enforced both locally and in CI.

## Goals

- Make quality checks fast, deterministic, and automated.
- Fail early on formatting/linting/test issues.
- Keep dependencies healthy and secure.
- Ensure every change is reviewed, testable, and well-described.

---

## Tests-first, Always

- For any non-trivial change:
  - Write/update tests as part of the same change.
  - Include both success and error paths.
  - For regressions, add a failing test first, then fix.
- When ambiguity exists, propose a minimal plan, implement in small steps, and include tests per step.

Recommended commands:
```
cargo test --all --all-targets
# (Optional) Faster test runner:
# cargo nextest run --all
```

---

## Formatting and Linting

### Rust

- rustfmt is mandatory for all Rust code.
- clippy must pass with no warnings in CI.
- Prefer stable toolchain; pin via `rust-toolchain.toml` to ensure reproducibility.

Local commands:
```
cargo fmt --all
cargo clippy --all-targets --all-features -D warnings
```

CI commands (non-fixing):
```
cargo fmt --all -- --check
cargo clippy --all-targets --all-features -D warnings
```

Clippy policy:
- Treat all warnings as errors in CI (`-D warnings`).
- If you must allow a lint, scope it narrowly and document the rationale:
  - Prefer line-level `#[allow(lint_name)]` with a comment.
  - Avoid crate-wide `allow` unless there’s a documented standard.

Optional stricter profile (opt-in per crate):
```
cargo clippy --all-targets --all-features -D warnings -W clippy::nursery -W clippy::pedantic
```

### Markdown/Docs

- Keep README and internal docs consistent with the current codebase.
- Use concise, task-focused prose; include command examples where helpful.

### CSS/SCSS (if present)

- Enforce a style linter (Stylelint) and formatting (Prettier) if configured.
- Keep class naming and tokens consistent with the Style guide.

---

## Dependency and Security Hygiene

- Lockfiles are committed and reviewed.
- Audit advisories regularly; CI must fail on unignored advisories.
- Track license and ban rules; CI must fail on violations.
- Keep dependencies reasonably up to date; avoid needless churn.

Commands:
```
# Audit for known vulnerabilities
cargo audit

# Policy checks: advisories, bans, licenses, sources
cargo deny check advisories
cargo deny check bans
cargo deny check licenses
cargo deny check sources

# Identify outdated dependencies
cargo outdated -R
```

Notes:
- If an advisory cannot be addressed immediately, document a temporary allowlist entry with justification, scope, and an expiration/revisit date.
- Prefer minimal dependency graphs; remove unused crates.

---

## Minimal GitHub Actions Example (Rust)

This is a reference you can adapt (paths/flags may differ per repo):

```
name: CI

on:
  pull_request:
  push:
    branches: [ main ]

jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Pin stable toolchain; add rustfmt + clippy components
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      # Cache build artifacts
      - uses: Swatinem/rust-cache@v2

      - name: Format (check)
        run: cargo fmt --all -- --check

      - name: Lint (clippy)
        run: cargo clippy --all-targets --all-features -D warnings

      - name: Test
        run: cargo test --all --all-targets --no-fail-fast

      # Optional: install extra tools for scanning
      - name: Install security tools
        run: |
          cargo install cargo-audit || true
          cargo install cargo-deny || true
          cargo install cargo-outdated || true

      - name: Audit (vulnerabilities)
        run: cargo audit

      - name: Deny (policies)
        run: |
          cargo deny check advisories
          cargo deny check bans
          cargo deny check licenses
          cargo deny check sources

      - name: Outdated (report only)
        run: cargo outdated -R || true
```

Tips:
- Make CI fail on format/lint/test/audit/deny; keep “outdated” informational.
- For monorepos/workspaces, prefer `--workspace` flags if appropriate.

---

## Pre-commit (Optional but Encouraged)

Add a lightweight local workflow so obvious issues never reach CI:
```
cargo fmt --all
cargo clippy --all-targets --all-features -D warnings
cargo test --all --all-targets
```
You can wire this via:
- git hooks (e.g., pre-commit framework), or
- a task runner (Justfile/Makefile) and an internal convention (“run just check before pushing”).

---

## Commit Message and PR Guidance

### Commits

- Use clear, imperative subject lines (max ~72 chars).
- Keep commits focused and logically atomic.
- Reference issues when relevant.
- Conventional Commits are encouraged:

Examples:
- feat(api): add pagination to list endpoint
- fix(db): handle unique constraint violation
- refactor(domain): extract validation into new module
- test(axum): add error-path tests for auth middleware
- docs(readme): clarify local setup instructions
- chore(ci): enable cargo-deny bans and licenses checks

### Pull Requests

- Keep PRs small and focused. If large:
  - Propose a plan, split into reviewable steps.
- PR Checklist (include in description):
  - Summary of change and rationale
  - Affected modules/crates
  - Tests added/updated (success + error paths)
  - Any migration steps or breaking changes
  - Security considerations (input validation, secrets, PII)
  - Performance considerations (if applicable)
- Screenshots or logs for UX/behavioral changes (where helpful)
- Link to related issues, designs, or discussions

---

## AI Assistant Requirements (Model-agnostic)

- When proposing code changes:
  - Include the exact commands to validate (format, lint, test, audit, deny).
  - Generate or update tests; call out new files and why they’re needed.
  - If a change is large, outline a plan and implement iteratively.
- Never introduce `unwrap()`/`expect()` in runtime code; use typed errors and proper propagation.
- Avoid leaking secrets/PII in logs, diffs, or examples; redact when necessary.
- Prefer minimal diffs; for broad refactors, coordinate via plan + staged PRs.

---

## Configuration Artifacts (Recommended to Check In)

- rust-toolchain.toml specifying stable channel and components (rustfmt, clippy).
- rustfmt.toml for project formatting preferences (if you need non-defaults).
- Clippy configuration comments at module/crate level only when justified.
- cargo-deny config (bans, licenses) aligned with org policy.
- Optional: EditorConfig, Stylelint, Prettier for non-Rust files.

---

## Recap Checklist

- [ ] Tests added/updated for all non-trivial changes
- [ ] cargo fmt passes (CI uses --check)
- [ ] cargo clippy passes with -D warnings
- [ ] cargo test passes (or cargo nextest)
- [ ] cargo audit has no unaddressed advisories
- [ ] cargo deny checks pass (advisories/bans/licenses/sources)
- [ ] Commit messages are clear (prefer Conventional Commits)
- [ ] PR description includes rationale, tests, and considerations
- [ ] No secrets/PII leaked in code, logs, or diffs

Adopting these rules ensures consistent, high-quality changes and smooth collaboration, whether changes are authored manually or assisted by Claude Sonnet 4 or GPT‑5.


## Source: global/global.md


# Global AI Rules for This Workspace

These rules are model-agnostic and apply equally when using Claude Sonnet 4 or GPT‑5 in Zed. They define how to structure assistance, keep changes safe, and maximize developer productivity.

## Purpose
- Provide consistent, high-quality assistance across languages and stacks in this workspace.
- Keep changes safe, auditable, and reversible.
- Remain interchangeable between models without provider-specific tokens or features.

## Response Style
- Be concise by default; expand only when clarification or safety warrants it.
- Prefer straightforward, simple solutions; avoid overengineering and unnecessary abstraction.
- Prefer stepwise, incremental changes. For large tasks, propose a plan first, then implement in small, reviewable steps.
- When editing code, include complete, compilable snippets and enumerate every file to add/modify/delete.
- Default to minimal diffs. For multi-file or structural changes, outline a migration plan before code.
- When the request is ambiguous, ask one focused clarifying question, then proceed with a safe assumption if needed.

## Safety & Privacy
- Never include secrets, tokens, private keys, API keys, passwords, or personal data in prompts or outputs.
- Redact or summarize sensitive logs and configuration (e.g., env vars). Do not echo raw secrets.
- Avoid sending large or unbounded context; include only the minimum required excerpts.
- Treat any user content as potentially sensitive; anonymize examples where possible.
- If external access or network calls are relevant, explicitly note the requirement and ask for consent and configuration, rather than assuming access.

## Output Constraints and Chunking
- If an answer risks exceeding model/editor limits:
  - Propose a plan and split into numbered steps.
  - Deliver the first step, await confirmation, then continue.
- For generated code, ensure each step compiles/tests independently where feasible.

## Tests-First Policy
- For any non-trivial change:
  - Add or update tests alongside code.
  - Cover both success and error paths, including edge cases.
  - Prefer fast, deterministic tests; isolate external dependencies with interfaces/mocks.
- If adding tests is impractical in the current step, explain why and propose a follow-up test task.

## Ambiguity Handling
- Ask 1–2 targeted questions when requirements are unclear.
- If time-critical, state assumptions explicitly and choose conservative defaults.
- Document trade-offs and implications of chosen defaults.

## Provider-Agnostic Usage (Claude Sonnet 4 and GPT‑5)
- Treat both models as interchangeable. Do not rely on provider-specific prompt syntax or tool APIs.
- Heuristics (non-binding):
  - Prefer Claude Sonnet for architectural reasoning, refactors across files, and planning.
  - Prefer GPT‑5 for focused code generation, structured transformations, and schema-heavy tasks.
- If a task seems better suited to one model, state the rationale and proceed with either model unless the user requests a switch.

## Request Pattern (Repeatable Loop)
1) Analyze: restate the objective, constraints, and risks.
2) Propose: outline a short plan (steps, files, tests).
3) Implement: apply step 1 with minimal diffs and complete code/context.
4) Validate: note build/test commands to run and expected outcomes.
5) Iterate: await feedback before proceeding to next steps.

## Change Size & Diffs
- Default to the smallest viable change that solves the problem.
- Provide a file-by-file change list; when applicable, include new/removed files.
- Prefer refactors in isolation from feature changes; sequence them if both are required.

## Code Quality Defaults
- Include all necessary imports and module declarations.
- Use explicit types for public APIs and complex expressions.
- Handle errors explicitly; avoid unwrap/expect in runtime paths.
- Add doc comments for public APIs, constraints, and examples.
- Follow language-idiomatic style and recommended linters/formatters (e.g., rustfmt/clippy, ESLint/Prettier, Stylelint).

## Security Expectations
- Validate inputs at system boundaries; sanitize before use or display.
- Map internal errors to safe external responses; never leak stack traces or internals.
- Apply timeouts, rate limits, and backpressure where appropriate.
- Use least-privilege access for credentials and services.
- Provide guidance for secret management (env vars, secret stores) without embedding secrets.

## Observability & Logging
- Use structured logging and correlation/request IDs.
- Log at appropriate levels; avoid logging sensitive data.
- Suggest health checks and basic metrics for new services or endpoints.

## Documentation & Comments
- Explain “why”, not just “what”. Call out assumptions, trade-offs, and limitations.
- Include usage examples for public functions/components.
- Update or create README snippets when adding meaningful features or workflows.

## Zed Integration Notes
- Optimize for navigation: consistent naming, clear module structures, and meaningful symbols for go-to-definition/find references.
- Keep imports ordered and deduplicated.
- When suggesting commands or scripts, prefer portable, single-shot commands (no long-running watchers).
- Respect file scoping: adhere to globs from specific ruleset files and keep unrelated changes out of scope.

## External Services & Commands
- Propose commands that terminate on their own (format, lint, test, build).
- For integrations (APIs, DBs), list required env vars/config and provide safe placeholders.
- Suggest migration/rollback steps where schema or contract changes occur.

## Anti-Patterns to Avoid
- Large, monolithic responses without a plan.
- Provider-specific prompt tokens or tool calls.
- Copying raw secrets, full logs, or large binary/config blobs.
- Mixing refactors with feature changes without a clear sequence.
- Omitting tests for non-trivial changes.

## Review Checklist (Quick)
- [ ] Small, incremental change with a clear plan
- [ ] Tests added/updated (success + failure paths)
- [ ] Explicit error handling; no unwrap/expect in runtime code
- [ ] Security/privacy respected; no secrets leaked
- [ ] Minimal, complete diffs with necessary imports and docs
- [ ] Observability notes (logging/metrics) when relevant
- [ ] Commands to validate (format, lint, test, build) are provided

---
These global rules ensure consistent, safe, and efficient collaboration with AI across this workspace, while remaining fully interchangeable between Claude Sonnet 4 and GPT‑5.


## Source: global/provider-guidance.md


# Provider-Agnostic Model Guidance (Claude Sonnet 4 and GPT-5)

This document makes the ruleset work interchangeably with Claude Sonnet 4 and GPT-5 in Zed. It provides model-neutral instructions, selection guidance by task type, and response-shaping patterns that produce consistent, reviewable results regardless of the chosen provider.

## Goals and Scope

- Keep all guidance provider-agnostic: no provider-specific prompt syntax, tokens, or tool calls.
- Ensure either model can follow the same rules and yield high-quality, maintainable code.
- Define a consistent workflow: plan → implement (with tests) → validate → iterate.

## Interchangeability Principles

- Neutral formatting and behavior
  - Avoid provider-specific features or directives.
  - Keep outputs deterministic: stable ordering of imports, consistent file lists, and fixed headings.
- Safety-first defaults
  - Do not include secrets, tokens, or PII in requests or responses.
  - Summarize or redact large logs/configs; share only the minimal necessary context.
- Test-first mindset
  - For non-trivial changes, propose or include tests alongside code.
  - Prefer incremental changes with validation steps.
- Clarify ambiguity
  - If requirements are unclear, ask one targeted clarifying question, then proceed with a conservative plan.

## Model Selection by Task Type

Both models should perform well with these rules. If you have a choice, consider:

- Architecture and multi-file planning
  - Use a deliberate “analyze → plan → implement” loop for refactors, layering, domain design, or interface contracts.
- Focused code generation and transformations
  - Use for implementing a concrete function, producing minimal diffs, bulk transformations, or mechanical refactors with precise constraints.
- Mixed tasks
  - Strategy: plan (high-level) → confirm → implement (incremental) → add tests → validate.
- Fallbacks
  - If one provider is unavailable or context-limited, propose a chunking plan and proceed with the other.

Note: Keep the language model choice flexible. When uncertain, briefly propose which model to use and why (based on the task characteristics), then proceed.

## Response-Shaping Patterns

### 1) Plan → Implement Loop
- Analyze the current state and constraints.
- Propose a short plan with:
  - The files to change (paths), the type of changes, and the test updates you’ll make.
  - Any risky or breaking steps explicitly called out.
- Await confirmation for multi-file or risky changes; otherwise proceed with the first step.
- Implement incrementally; after each step:
  - Summarize what changed.
  - Identify next steps and potential validations.

### 2) Chunking and Context Management
- If a response may exceed limits, do this:
  - Provide a concise plan and the list of affected files.
  - Implement the smallest valuable subset first (one module or feature slice).
  - Request to continue before producing additional slices.
- Prefer minimal diffs over full-file rewrites; when a full file is required (e.g., new files or fragmented context), make that explicit.

### 3) Diff vs Full-File Policy
- Default: minimal, self-contained edits that compile.
- Full-file only when:
  - The file is new.
  - The change is sweeping and safer to present as a full, complete file.
  - The editor/workflow explicitly requires full file content.

### 4) Tests With Changes
- For any non-trivial code, include/update tests in the same iteration:
  - Unit tests for pure logic.
  - Integration tests for API boundaries, error cases, and concurrency.
- State how to run tests (commands) without executing them.

### 5) Error Handling and Safety Baselines
- Rust/Axum:
  - No `unwrap`/`expect` in runtime code.
  - Typed errors; map external errors; never leak internals in HTTP responses.
  - Timeouts, limits, input validation at boundaries; structured logging with correlation IDs.
- Leptos:
  - Use `<ErrorBoundary>` and `<Suspense>`; handle loading and error states explicitly.
  - Avoid update loops; use selectors, keyed lists, and modern APIs consistently.
- CSS/SCSS:
  - Use design tokens, accessibility-friendly defaults, and reduced-motion fallbacks.

### 6) Privacy and Redaction
- Never include secrets or raw environment variables in prompts or outputs.
- Redact or summarize large or sensitive data.
- Minimize logs; provide structured, actionable summaries.

### 7) Clarifying Questions Policy
- Ask exactly one focused question when ambiguity blocks progress.
- If still uncertain after a response, propose a conservative default and proceed.

### 8) Deterministic Outputs
- Keep import ordering consistent (std → external → internal).
- Use stable wording for headings and checklists.
- Prefer explicit types, explicit trait bounds, and explicit error variants.

## Zed-Oriented Tips (Model-Neutral)

- Respect ruleset scoping via globs; keep changes within the current file set unless asked otherwise.
- Include complete module context (imports, feature flags, Cargo.toml updates when relevant).
- Reference developer commands (formatting, lint, test) but do not run them; provide the exact CLI incantations.
- Default to concise responses; expand details or reasoning upon request.
- Use incremental edits that are easy to navigate with Go-to-Definition and Find References.

## Workflow Recipes

### Small Fix Flow
1) Identify root cause and risk.
2) Propose a single-file, minimal change.
3) Implement the change and a focused test.
4) Describe how to run format/lint/tests.

### Multi-File Feature Flow
1) Propose a plan: files to add/change, interfaces, tests.
2) Implement in small steps (one submodule or layer at a time).
3) Add/update tests for each step; ensure error handling is consistent.
4) Summarize next steps; pause for confirmation if crossing boundaries (API, DB, build config).

### Refactor Flow
1) Inventory public APIs and call sites.
2) Propose a migration path:
   - Deprecate old API, introduce new API, create adapters if needed.
3) Apply changes incrementally with tests and clear deprecation notes.
4) Validate with lint/tests; ensure minimal churn to consumers.

### Incident/Bug Triage Flow
1) Reproduce and isolate the failing path.
2) Propose a minimal fix and a regression test.
3) Implement fix + test; add telemetry if missing.
4) Provide rollback/mitigation guidance if risk remains.

## Review Checklist (Any Model)

- Plan approved or conservative default chosen.
- Minimal diffs unless full-file is safer.
- Complete imports, types, and error handling.
- Tests included/updated for non-trivial changes.
- No secrets/PII; logs summarized/redacted.
- Performance implications considered for hot paths.
- Accessibility and security baselines respected.
- Clear run instructions (format, lint, test).
- Deterministic, consistent output formatting.

## Common Pitfalls and Mitigations

- Overlong responses → Split into steps; implement the smallest valuable subset.
- Ambiguous requirements → Ask one clarifying question; propose a safe default.
- Partial edits that don’t compile → Include all necessary imports/types and adjust signatures.
- Leaking sensitive data → Redact early; share only what’s essential.
- Hidden breaking changes → Call out risk; propose adapters/deprecations; add tests.

## Versioning and Upgrades

- Respect the project’s current versions and edition settings.
- Propose upgrades explicitly with a short risk assessment and a test/rollback plan.
- Keep feature flags and Cargo.toml updates localized and documented.

---

With these rules, Claude Sonnet 4 and GPT-5 can be used interchangeably in Zed. The guidance here standardizes how tasks are planned, executed, and validated, producing consistent, safe, and reviewable results across providers.


## Source: global/security-ai.md


# AI Security & Privacy Rules (Global)

Model-agnostic rules to keep code, data, and credentials safe while collaborating with AI in Zed. These rules apply to all files matched by this ruleset.

## Golden rules

- Never include secrets or raw PII in prompts, responses, diffs, or logs.
- Minimize context: share only what is strictly necessary to solve the task.
- Redact before sharing; use deterministic placeholders (e.g., "<REDACTED:API_KEY>").
- Ask for consent before any external network/API calls or uploads.
- Prefer synthetic/fake data and least-privilege design patterns.

## Definitions

- Secrets: API keys, tokens, passwords, private keys, client secrets, credentials, connection strings, session cookies, JWTs, cloud access keys, SSH keys, encryption keys.
- PII: Any data that can identify a person (name, email, phone, address, identifiers, IPs when tied to identity, device IDs). Treat “quasi-identifiers” as PII when combined (e.g., ZIP + birth date).
- Sensitive business data: Proprietary code, unreleased features, financial, legal, or security configurations.
- Safety-critical code: Authentication, authorization, crypto, payment processing, personal/medical data handlers.

## Default assistant behavior

- Minimize shared content: summarize large logs/configs; share only the essential lines and structure.
- Prefer references over raw values (e.g., "uses env var DB_PASSWORD" instead of actual value).
- Redact with explicit, typed placeholders:
  - "<REDACTED:API_KEY>", "<REDACTED:JWT>", "<REDACTED:ACCESS_TOKEN>", "<REDACTED:EMAIL>", "<REDACTED:PHONE>"
- Truncate long values (e.g., "sk_live_…<TRUNCATED>") after first 6–8 visible chars when context is necessary.
- Avoid echoing environment variables, .env contents, config files, or credentials. If absolutely necessary, include only variable names and sample placeholders.
- If uncertain whether data is sensitive, treat it as sensitive and ask one clarifying question.

## Secrets and credential hygiene

- Do not generate real credentials. Use placeholders and provide guidance to create and store secrets securely.
- Suggest maintaining ".env.example" with placeholders and ensuring ".env" is ignored by VCS.
- Never print secrets in logs, errors, or test output. Use masked forms or placeholders.
- Recommend rotation if a secret appears in code, history, logs, or discussion.
- Avoid embedding credentials in URLs or source; use environment variables or secret managers.
- For token-like strings, always redact before quoting or copying.

## PII handling

- Default to data minimization: avoid including real names, emails, or IDs.
- Use synthetic/fake data for examples (e.g., "Jane Doe", "jane@example.com", "+1-202-555-0100").
- Pseudonymize when troubleshooting (e.g., "User A", "Order #1234").
- Never post raw datasets, CSVs, or logs containing PII; provide schemas, small fake samples, or summaries.
- For analytics or telemetry examples, aggregate or hash identifiers; avoid unique raw identifiers when not needed.

## Logging and tracing

- Prefer structured, minimal logs: event name, correlation/request ID, high-level error category.
- Avoid logging secrets, tokens, full headers, or entire request/response bodies.
- Cap log sizes, fields, and arrays; omit or hash large or sensitive fields.
- Return safe error responses to clients (no internal stack traces or config details).
- Use correlation IDs for tracing instead of duplicating user or sensitive identifiers.

## External calls, uploads, and tooling

- Obtain explicit consent before:
  - Calling external APIs or services.
  - Uploading files/snippets to third-party endpoints.
  - Using remote code execution, package queries, or automated fetchers.
- When proposing an external call, specify:
  - Endpoint, purpose, and expected benefit.
  - Data categories involved (e.g., metadata only, no PII/secrets).
  - Data minimization strategy (masking, sampling).
  - Alternatives if external calls are disallowed.
- Respect organizational constraints (proxies, allowlists, approval workflows). If unknown, assume restricted and ask.

## Compliance guidance (non-exhaustive, not legal advice)

- GDPR/CCPA: minimize personal data; provide deletion/anonymization paths; log only what is necessary.
- HIPAA: treat PHI as highly restricted; avoid sharing; use de-identified data for examples.
- PCI-DSS: never handle raw PAN/CVV in logs or code snippets; use tokenization.
- SOC 2: prefer least-privilege, auditing, change control; avoid uncontrolled data egress.
- If a change could impact compliance, flag it and recommend review by security/privacy stakeholders.

## Source code and licensing

- Avoid pasting large third-party code blocks; link, summarize, or cite instead.
- Respect licenses; avoid incorporating incompatible-licensed code into proprietary repos.
- Recommend license and vulnerability checks for dependencies; keep audit findings out of public contexts.

## Data classification defaults

- Treat repository content as Confidential by default.
- Assume external sharing is prohibited unless explicitly approved.
- If classification is unclear, ask for confirmation and proceed with the most restrictive assumption.

## Incident handling (suspected exposure)

- Stop propagation: do not repeat or further disseminate sensitive content.
- Summarize minimally what was exposed (type, scope, time) without repeating the data.
- Recommend immediate actions: rotate keys, revoke tokens, invalidate sessions, purge caches.
- Suggest notifying the responsible security/contact channel with minimal necessary details.

## Review checklist (apply before posting responses)

- [ ] No secrets, tokens, or credentials included.
- [ ] No raw PII; synthetic or redacted data only.
- [ ] Logs/configs minimized; only essential lines included.
- [ ] Any proposed external call includes purpose, minimization, and consent request.
- [ ] Error messages safe; no internal details leaked.
- [ ] Test data uses fakes; no production samples.
- [ ] Licensing respected; no large third-party code pasted.
- [ ] Recommendations include secret rotation if exposure suspected.
- [ ] Compliance-sensitive areas flagged when relevant.
- [ ] The least-privilege and data-minimization principles are followed.

## Safe example patterns (non-executable)

- Environment variables: show names only (e.g., "DB_USER", "DB_PASSWORD") with placeholder values.
- Credentials in URLs: never include; show pattern "postgres://<USER>:<REDACTED:PASSWORD>@host/db".
- JWTs, session cookies: show as "<REDACTED:JWT>" or "sid=…<TRUNCATED>".
- Logs: log event codes and correlation IDs; omit payloads unless strictly necessary and sanitized.

## Opt-in templates

Use these templates to align requests/responses with safe practices.

- Redaction acknowledgment:
  - "Detected sensitive content (type: API key). Redacting and proceeding with a minimal, masked example. Recommend rotating the affected credential and updating secrets storage."

- External call consent request:
  - "To fetch X, propose calling Y (method: GET, scope: metadata only, no PII, no secrets). I will mask identifiers and share only necessary headers. Proceed?"

## What to do when in doubt

- Ask one focused clarifying question, propose the safest default, then proceed minimally.
- Prefer a plan-first approach for large contexts or ambiguous requirements.
- Stop and flag to stakeholders if continuing might cause data exposure.

---
By following these rules, assistants and contributors maintain strong security posture across models and workflows while enabling effective, privacy-preserving collaboration in Zed.

