use crate::domain::entities::Account;
use crate::domain::services::access_policy::AccessPolicy;
use crate::domain::services::authorization::AuthorizationService;
use crate::domain::traits::AccessHierarchy;
use crate::infrastructure::jwt::{
    JwtClaims, JwtValidationResult, JwtValidationService, RegisteredClaims,
};
use crate::ports::Codec;

use std::convert::Infallible;
use std::fmt::Debug;
use std::future::Future;
use std::pin::Pin;
use std::sync::Arc;

#[cfg(feature = "audit-logging")]
use crate::infrastructure::audit;
use axum::{body::Body, extract::Request, http::Response};
use axum_extra::extract::cookie::{Cookie, CookieJar};
use cookie::CookieBuilder;
use http::StatusCode;
use tower::Service;
use tracing::{debug, trace, warn};

/// The gate is protecting your application from unauthorized access.
#[derive(Debug, Clone)]
pub struct CookieGateService<C, R, G, S>
where
    C: Codec,
    R: AccessHierarchy + Eq + std::fmt::Display,
    G: Eq + Clone,
{
    inner: S,
    authorization_service: AuthorizationService<R, G>,
    jwt_validation_service: JwtValidationService<C>,
    cookie_template: CookieBuilder<'static>,
    /// If `true`, the service will ALWAYS forward the request and install
    /// `Option<Account<R,G>>` and `Option<RegisteredClaims>` extensions:
    /// - `Some(..)` when a valid JWT cookie is present (policy IS NOT evaluated)
    /// - `None` when missing / invalid token
    /// In this mode no 401 response is generated by the gate; handler code
    /// must perform any required access checks.
    install_optional_extensions: bool,
}

impl<C, R, G, S> CookieGateService<C, R, G, S>
where
    C: Codec,
    R: AccessHierarchy + Eq + std::fmt::Display,
    G: Eq + Clone,
{
    /// Creates a new instance of a cookie gate service (strict mode).
    pub fn new(
        inner: S,
        issuer: &str,
        policy: AccessPolicy<R, G>,
        codec: Arc<C>,
        cookie_template: CookieBuilder<'static>,
    ) -> Self {
        Self {
            inner,
            authorization_service: AuthorizationService::new(policy),
            jwt_validation_service: JwtValidationService::new(codec, issuer),
            cookie_template,
            install_optional_extensions: false,
        }
    }

    /// Creates a new instance in "optional extensions" mode.
    ///
    /// Public for advanced usage; normally constructed by the `Gate` builder when
    /// `with_optional_extensions()` is used.
    pub fn new_with_optional_extensions(
        inner: S,
        issuer: &str,
        codec: Arc<C>,
        cookie_template: CookieBuilder<'static>,
    ) -> Self {
        // In optional mode we ignore the policy completely, but we still supply a
        // deny-all policy object (it is never consulted).
        Self {
            inner,
            authorization_service: AuthorizationService::new(AccessPolicy::deny_all()),
            jwt_validation_service: JwtValidationService::new(codec, issuer),
            cookie_template,
            install_optional_extensions: true,
        }
    }
}

impl<C, R, G, S> CookieGateService<C, R, G, S>
where
    C: Codec,
    R: AccessHierarchy + Eq + std::fmt::Display,
    G: Eq + Clone,
{
    /// Queries the axum-gate auth cookie from the request.
    pub fn auth_cookie(&self, req: &Request<Body>) -> Option<Cookie<'_>> {
        let cookie_jar = CookieJar::from_headers(req.headers());
        let cookie = self.cookie_template.clone().build();
        cookie_jar.get(cookie.name()).cloned()
    }

    /// Used to return the unauthorized response.
    fn unauthorized() -> Response<Body> {
        Response::builder()
            .status(StatusCode::UNAUTHORIZED)
            .body(Body::from("Unauthorized"))
            .unwrap()
    }
}

impl<C, R, G, S> Service<Request<Body>> for CookieGateService<C, R, G, S>
where
    S: Service<Request<Body>, Response = Response<Body>, Error = Infallible> + Send + 'static,
    S::Future: Send + 'static,
    Account<R, G>: Clone,
    C: Codec<Payload = JwtClaims<Account<R, G>>>,
    R: AccessHierarchy + Eq + std::fmt::Display + Sync + Send + 'static,
    G: Eq + Clone + Sync + Send + 'static,
{
    type Response = Response<Body>;
    type Error = Infallible;
    type Future =
        Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send + 'static>>;

    fn poll_ready(
        &mut self,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }

    fn call(&mut self, mut req: Request<Body>) -> Self::Future {
        let unauthorized_future = Box::pin(async move { Ok(Self::unauthorized()) });

        #[cfg(feature = "audit-logging")]
        let _audit_request_span =
            audit::request_span(req.method().as_str(), req.uri().path(), None);
        #[cfg(feature = "audit-logging")]
        let _audit_request_enter = _audit_request_span.enter();

        // OPTIONAL MODE: Always forward; install Option<Account> / Option<RegisteredClaims>
        if self.install_optional_extensions {
            let mut opt_account: Option<Account<R, G>> = None;
            let mut opt_reg_claims: Option<RegisteredClaims> = None;

            if let Some(auth_cookie) = self.auth_cookie(&req) {
                trace!("axum-gate (optional) cookie: {auth_cookie:#?}");
                let cookie_value = auth_cookie.value_trimmed();
                if let JwtValidationResult::Valid(jwt) =
                    self.jwt_validation_service.validate_token(cookie_value)
                {
                    // Insert concrete types for convenience
                    req.extensions_mut().insert(jwt.custom_claims.clone());
                    req.extensions_mut().insert(jwt.registered_claims.clone());

                    opt_account = Some(jwt.custom_claims.clone());
                    opt_reg_claims = Some(jwt.registered_claims.clone());
                } else {
                    debug!("Optional mode: invalid or mismatched JWT, installing None extensions");
                }
            } else {
                trace!("Optional mode: no auth cookie present; installing None extensions");
            }

            // Always insert the Option variants
            req.extensions_mut().insert(opt_account);
            req.extensions_mut().insert(opt_reg_claims);

            let inner = self.inner.call(req);
            return Box::pin(inner);
        }

        if self.authorization_service.policy_denies_all_access() {
            debug!("Denying access because roles, groups or permissions are empty.");
            #[cfg(feature = "audit-logging")]
            {
                audit::denied(None, "policy_denies_all");
            }
            return unauthorized_future;
        }

        let Some(auth_cookie) = self.auth_cookie(&req) else {
            #[cfg(feature = "audit-logging")]
            {
                audit::denied(None, "missing_cookie");
            }
            return unauthorized_future;
        };
        trace!("axum-gate cookie: {auth_cookie:#?}");

        let cookie_value = auth_cookie.value_trimmed();
        let jwt = match self.jwt_validation_service.validate_token(cookie_value) {
            JwtValidationResult::Valid(jwt) => jwt,
            JwtValidationResult::InvalidToken => {
                debug!("JWT token validation failed");
                #[cfg(feature = "audit-logging")]
                {
                    audit::jwt_invalid_token("validation_failed");
                }
                return unauthorized_future;
            }
            JwtValidationResult::InvalidIssuer { expected, actual } => {
                warn!(
                    "JWT issuer validation failed. Expected: '{}', Actual: '{}', Account: {}",
                    expected, actual, "unknown"
                );
                #[cfg(feature = "audit-logging")]
                {
                    audit::jwt_invalid_issuer(&expected, &actual);
                }
                return unauthorized_future;
            }
        };

        debug!("Logged in with id: {}", jwt.custom_claims.account_id);

        #[cfg(feature = "audit-logging")]
        let _authz_span = audit::authorization_span(Some(&jwt.custom_claims.account_id), None);
        #[cfg(feature = "audit-logging")]
        let _authz_enter = _authz_span.enter();

        let account = &jwt.custom_claims;
        let is_authorized = self.authorization_service.is_authorized(account);

        if !is_authorized {
            #[cfg(feature = "audit-logging")]
            {
                audit::denied(Some(&jwt.custom_claims.account_id), "policy_denied");
            }
            return unauthorized_future;
        }

        #[cfg(feature = "audit-logging")]
        {
            audit::authorized(&jwt.custom_claims.account_id, None);
        }

        req.extensions_mut().insert(jwt.custom_claims.clone());
        req.extensions_mut().insert(jwt.registered_claims.clone());

        let inner = self.inner.call(req);
        Box::pin(inner)
    }
}
